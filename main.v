Require Import List.
Import ListNotations.
Require Import Classes.EquivDec.
Require Import Coq.Program.Program.
Require Import Bool.
Require Import ListSet.

(*leave the type inference at maximum level in Coq, not being necessary to declare the type*)
(*of parameters of functions, as seen in https://coq.inria.fr/cocorico/CoqNewbieQuestions  *)

Set Implicit Arguments.
(*Coq will try to infer at maximum level the arguments' types *)
Set Maximal Implicit Insertion.

(* First, some library helper functions and notations. *)
(* https://coq.inria.fr/distrib/current/refman/Reference-Manual023.html#hevea_command261/ *)
(*Instance: in this case, the Instance keyword creates a instance of the EqDec class,i.e, *)
(*creates an instance of an equality relation for the type option A (A: Type)             *)
(*Program : gives a way to write programs as if they were written in a regular functional *)
(*programming language, such as Haskell, using the Coq proof apparatus to generate a sound*)
(*program from the specification given.                                                   *)

(*eq: equality relation, it is an inductive proposition that gives the notion of equality *)
(*between 2 elements of the same type. It is in Coq.Init.Logic.                           *)

Obligation Tactic := unfold complement, equiv ; program_simpl.
(*needed tactic, so the obligations generated by Program to deal with the proof of the sound*)
(*ness is solved automatically by the Program keyword.                                     *)

Program Instance option_eqdec A `(EqDec A eq) : EqDec (option A) eq :=
{
  equiv_dec x y :=
    match x, y with
      | Some a, Some b => if a == b then in_left else in_right
      | None, None => in_left
      | Some _, None | None, Some _ => in_right
    end
 }.
(* Equality decidion procedure for pairs *)
Program Instance pair_eqdec A B `(EqDec A eq) `(EqDec B eq) : EqDec (A * B) eq :=
{
  equiv_dec x y :=
    match x,y with
      | pair a b, pair c d => if (a == c) then 
                              if (b == d) then in_left else in_right
                              else in_right
    end
}.
Definition filterMap {A B} (f : A -> option B) : list A -> list B :=
  fix rec (l : list A) : list B :=
    match l with
    | [] => []
    | x :: l => match f x with
               | None => rec l
               | Some y => y :: rec l
               end
    end.

Definition add_list_to_set {A} `{EqDec A eq} : list A -> set A :=
  fix rec l :=
    match l with
    | [] => []
    | a::t => set_add equiv_dec (a) (rec t)
  end.  

(* We define a function that computes the powerset of a set *)
Fixpoint powerset {A} (l:set A) : set (set A) :=
match l with
  | [] => [[]]
  | a::t => concat (map (fun f => [a::f;f]) (powerset t))
end.

(* Returns true if all elements of s1 is in s2 *)
Fixpoint s1_in_s2 {A} `{EqDec A eq} (s1 s2 : set A) :=
  match s1 with
    | [] => true
    | a::t => set_mem equiv_dec a s2 && s1_in_s2 t s2
  end.

Fixpoint set_eq {A} `{EqDec A eq} (s1 s2 : set A) :=
  if (length s1 == length s2) then
      if (s1_in_s2 s1 s2) then
          if (s1_in_s2 s2 s1) then true else false
      else false
  else false.


Notation "x |> f" := (f x) (left associativity, at level 69, only parsing).

(* A type representing valid right-hand sides of left-regular grammar rules.
   The original email used a much looser representation of rules, which did not
   separate the LHS from the RHS, and which did not enforce regularity. By
   restricting the representation, we make it easier to write a parser. *)
Module rhs.
  (*RHS: Right Hand Side: How right linear regular grammar should behave:its rules should  *)
  (*be A -> a, A -> a B or A -> e, where A and B denotes nonterminal symbols and a denotes.*)
  (* a terminal symbol.                                                                    *)

  Inductive t T NT :=
  | Empty : t T NT
  | Single : T -> t T NT
  | Continue : T -> NT -> t T NT.
  (* Coq will infer the type of the arguments of the constructors of the RHS type, as seen in *)
  (*https://coq.inria.fr/distrib/current/refman/Reference-Manual004.html#hevea_command59      *)
  (* so we don't have to worry about expliciting the types every now and then. *)

  Arguments Empty {_} {_}.
  Arguments Single {_} {_} _.
  Arguments Continue {_} {_} _ _.
  (*the function below checks whether a rule is empty or not, given the terminal and nonterminal    *)
  (*and the RHS of a rule, returns true if this RHS is Empty, otherwise, returns false        *)
  Definition isEmpty (T NT : Type) (rhs : rhs.t T NT) : bool :=
    match rhs with
    | Empty => true
    | _ => false
    end.

  Module exports.
    Notation Empty := Empty.
    Notation Single := Single.
    Notation Continue := Continue.
  End exports.
End rhs.
Import rhs.exports.

(* A helper to give us the notion of equality over RHS *)
Program Instance rhs_eqdec A B `(EqDec A eq) `(EqDec B eq) : EqDec (rhs.t A B) eq :=
{
  equiv_dec x y :=
    match x,y with
      | Empty, Empty => in_left
      | Single a, Single b => if a == b then in_left else in_right
      | Continue a nt, Continue b nt' => if a == b then
                                         if nt == nt' then in_left else in_right
                                      else in_right
      | Empty, Single _ => in_right
      | Empty, Continue _ _ => in_right
      | Single _, Empty => in_right
      | Single _, Continue _ _ => in_right
      | Continue _ _, Empty => in_right
      | Continue _ _, Single _ => in_right
    end
}.

Module reg_grammar.
  Section reg_grammar.
    Variable T NT: Type.
    Context  `{EqDec T eq} `{EqDec NT eq}.
    (*When using this, it is possible to use the notion of equality between elements of type*)
    (* T and NT                                                                             *)
    Record g : Type:= {
      start_symbol: NT;
      rules : set (NT * rhs.t T NT);
      terminal_symbols : set T;
      nonterminal_symbols : set NT
    }.

    (* Note that the terminal symbols and nonterminal symbols are sets implemented as lists *)
    (* It fails if the user provides directly to the record a list with repeated symbols    *)    
    Definition build_grammar (nt: NT) rules alphabet nonterminal: g :={|
      start_symbol := nt;
      rules := add_list_to_set (rules);
      terminal_symbols := add_list_to_set (alphabet) ;
      nonterminal_symbols := add_list_to_set (nonterminal) |}.

  (* Next, we're going to write a function [parse] that decides whether a string
     is in the language represented by the grammar. The parser keeps track of
     the set of nonterminal symbols it's currently in, with the additonal
     special symbol None representing "end of string when the last rule applied
     had RHS [Single]". *)

  (* It may help to scroll down to the function [parse] first, and read
     backwards up to here. *)

  (* Given the RHS of a rule and a terminal, decides whether the RHS can be used. *)
  (* In others words, given a RHS of a rule and a terminal symbol, it checks how, if it *)
  (* can be used, the RHS will be used.                                            *)
  Definition step_rhs (t : T) (rhs : rhs.t T NT) : list (option NT) :=
    match rhs with
    | Empty => []
    | Single t' => if t == t' then [None] else []
    | Continue t' nt => if t == t' then [Some nt] else []
    end.

  (* Finds all the productions for a given nonterminal. *)
  (*Note: this list will never be empty, if the nt symbol belongs to the grammar   *)
  Definition getRHS `{EqDec NT eq}
           (nt : NT) : set (NT * rhs.t T NT) ->
                       set (rhs.t T NT) :=
    filterMap (fun rule => let '(nt', rhs) := rule in
                        if nt == nt' then Some rhs else None).


  (* Given a nonterminal [nt], applies all possible rules,applying step_rhs on the             *)
  (* list of nonterminal symbols obtained by applying getRHS nt with the rules of the grammar  *)

  Definition step_nt (rules : set(NT * rhs.t T NT)) (t : T) (nt : NT) : set (option NT) :=
    rules |> getRHS nt  |> flat_map (step_rhs t).


  (* Given a *list* of nonterminals, takes all possible next steps. *)
  (*map: returns 1 value for each application of the function for each element of the list. *)
  (*flat_map: returns 0 or more values for each application of the function in each list element.*)
  (*if applyable *)
  Definition step (rules : set (NT * rhs.t T NT)) (t : T) (acc : set NT) : set (option NT) :=
    acc |> flat_map (step_nt rules t) |> nodup equiv_dec .


  (* The main parser loop. Repeatedly steps the current set of states using
     terminals from the string. *)
  Definition parse' (rules : set (NT * rhs.t T NT))
           : list T -> set (option NT) -> set (option NT) :=
    fix rec l acc :=
      match l with
      | [] => acc
      | t :: l =>
    (*filtermap id : acc gets the elements of t::l. *)
        acc |> filterMap id
            |> step rules t
            |> rec l
      end.
  (* Checks to see if the current state represents an accepting state.  In this
     representataion of state, a state is accepting if it contains [None] or if
     it contains [Some nt] and there is a rule [(nt, Empty)].  *)
  Definition is_final (rules : set (NT * rhs.t T NT)) (l : set (option NT)) : bool :=
  (*existsb: boolean exists, chech whether a condition can
   be met by any of the elements in l*)
  (*This function is in Coq.Lists, where o is an element of the list l.*)
  (* Note that the order of the elements in this list does not affect the result,*)
  (* because for all elements of the list it is checked whether a state is final *)
  (*according to the rules.                                                      *)
    existsb (fun o => match o with
                   | None => true
                   | Some nt => getRHS nt rules |> existsb rhs.isEmpty
                   end)
            l.
  (* Top-level parse function. Calls [parse'] with the initial symbol and checks
     to see whether the resulting state is accepting. *)
  Definition parse (grammar : reg_grammar.g) (l : list T): bool :=
    [Some (start_symbol grammar)] |> parse' (rules grammar) l |> is_final (rules grammar).

  (*Returns the final derivation state of the grammar *)
  Definition parse_aux (grammar: reg_grammar.g) (l:list T) :=
   [Some (start_symbol grammar)] |> parse' (rules grammar) l.

  End reg_grammar.
End reg_grammar. 

(* Nondeterministic finite automata *)
Module nfa.
  Section nfa.
    Variable (A ST : Type).
    Context  `{EqDec ST eq} `{EqDec A eq}.

    Record t := NFA {
      initial_state : ST;
      is_final : ST -> bool;
      next : A -> ST -> set ST;
      states: set ST;
      alphabet: set A
   }.
    (* run' is the function that does the verification steps of the automata, applying     *)
    (* the transition functions in the list of terminal symbols, returning a state, which  *)
    (* can be final or not.                                                                *)

    Definition step (nfa:t) (states : set ST) (t:A) : list ST :=
      states |> flat_map (next nfa t).

    (* Since a NFA can have multiple paths for a single run, we have to check them all. *)
    Definition run' (m: t)
           : list A -> set ST -> set ST :=
    fix rec l acc :=
      match l with
      | [] => acc
      | t :: l => step m acc t
               |> rec l
      end.
    (* The acceptance criteria is sliglty modified : since we can reach more than one state *)
    (* while going through a word, we have to check whether the nfa can be at (at least) one*)
    (* final state. The verify_final_state function goes though a list of possible states   *)
    (* and checks if one of them is a final state. The run function will go through a word, *)
    (* returning true iff the nfa reached a final state, otherwise it returns false.        *)

    Definition verify_final_state' (m:t) (states: set ST) :=
      existsb (fun x => is_final m x) states.

    (* We call the above function to check whether the run in the nfa returns true or false. *)
    Definition run (m : t) (l : list A) : bool :=
     verify_final_state' m ((run' (m) l  ([initial_state m]))).
    Definition run2 (m :t) (l : list A) : set ST :=
      nodup equiv_dec (run' (m) l  ([initial_state m])).

    (* The path function returns all the states the automata have been while consuming the *)
    (* word given to be checked whether it is recognizable by the automata or not.         *)
    Definition get_trace (m:t) : list A -> list ST -> list (list ST) -> list (list ST):=
      fix rec l acc res :=
        match l with
        | [] => res
        | t::l => (res ++ ([step m acc t |> nodup equiv_dec])) |> rec l (step m acc t)
        end.

    Definition path (m:t) (l:list A) : list (set ST) :=
      get_trace m l [initial_state m] [[initial_state m]].

  Fixpoint create_continue_rule_from_list (s:ST) (ls:set ST) (a:A) :=
    match ls with  
    | [] => []
    | x::t => set_add equiv_dec (s,Continue a x) (create_continue_rule_from_list s t a)
    end.

  (*The next 3 functions returns all states acessible from a given state of the NFA *)
  (* TODO prove this in the .PDF                                                    *)
  Fixpoint expand_a_state (m:t) (s:ST) (l: list A) :=
  match l with
  | [] => []
  | a::t => set_union equiv_dec (nfa.next m a s) (expand_a_state m s t)
  end.

  Program Fixpoint bounded_search (m:t) (n:nat) (x y: ST) :=
  match n with
  | O => if x == y then true else false
  | S k => if x == y then true else
            existsb (fun x => bounded_search m k x y) 
                    (expand_a_state m x (nfa.alphabet m))
  end.

  Fixpoint get_all_reachable_states_from_a_state (m:t) (state:ST) (s: set ST): set ST :=
  match s with
  | [] => []
  | a::t => if (bounded_search m (length(nfa.states m)) (state) a)
            then set_add equiv_dec (a) (get_all_reachable_states_from_a_state m state t)
            else get_all_reachable_states_from_a_state m state t 
  end.

  Definition get_all_related_states (m:t) (state:ST) :=
    get_all_reachable_states_from_a_state m state (nfa.states m).

  (* We can build a regular grammar from a NFA: *)

  (* Gets all possible nonempty rules from every transition from the NFA *)
  Definition get_every_state (m:t) (s: ST) : set A -> set (ST * rhs.t A ST) :=
    fix rec l :=
      match l with
      | [] => []
      | a::t => set_union equiv_dec (
                match (nfa.next m a s) with
                | [] => []
                | b::y => (create_continue_rule_from_list (s) (nfa.next m a s) (a))
                end)
    (rec t)
    end. 

  (* Gets all rules from all states of the NFA *)
  Fixpoint get_all_rules (m:t) (s: set ST) (l: set A): 
  set (ST * rhs.t A ST):=
  match s with
    | [] => []
    | a::x =>  set_union equiv_dec (get_every_state m a l)
               (get_all_rules m x l)
  end.
  (*Creates empty rule from a set of states, getting all final states of the *)
  (* NFA and then creating rules of the kind A -> e                          *)
  Fixpoint create_empty_rules (m:t) (ls:set ST) :
  set (ST * rhs.t A ST) :=
    match ls with  
    | [] => []
    | x::t => if (nfa.is_final m x) then
              set_add equiv_dec (x,Empty) (create_empty_rules m t)
              else (create_empty_rules m t)
    end.

  (* For every state that is final, we create a rule of the kind (A,Empty) *)
  Fixpoint get_empty_rules (m:t) (s: ST) (l2: list A): set (ST * rhs.t A ST) :=
  match l2 with
  | [] => []
  | a::x => set_union equiv_dec (create_empty_rules m ((nfa.next m a s))) 
            (get_empty_rules m s x)
  end.
  (* Gets all empty rules of the resulting grammar for all nonterminals*)
  Fixpoint add_empty_rules (m:t) (l1: list ST) (l2: list A)
  : set (ST * rhs.t A ST) :=
  match l1 with
  | [] => []
  | a::t => set_union equiv_dec (get_empty_rules m a l2) (add_empty_rules m t l2)
  end.
  (* Function that gets both all possible derivation rules from the NFA *)
  Definition nfa_transitions_to_grammar_rules (m:t) (l1:list ST) (l2:list A) := 
   set_union equiv_dec
  (get_all_rules m l1 l2) (add_empty_rules m l1 l2).

  (* To create a regular grammar from a NFA, one may call the above function: *)
  Definition build_grammar_from_nfa (m:t) :=
    reg_grammar.build_grammar (nfa.initial_state m) 
    (nfa_transitions_to_grammar_rules m (nfa.states m) (nfa.alphabet m))
    (nfa.alphabet m) (nfa.states m).

  End nfa.
End nfa.

(* From a regular grammar we can build a NFA that recgonizes the same language *)
Module grammar_to_nfa.
  Section grammar_to_nfa.

  Variables T NT: Type.
  Context `{EqDec T eq} `{EqDec NT eq}.
  Variable g : reg_grammar.g T NT.
  Definition state : Type := option NT.
  Definition init := Some (reg_grammar.start_symbol g).

  Definition final (s : state) : bool :=
    match s with
      | None => true
      | Some nt => reg_grammar.getRHS nt (reg_grammar.rules g) |> existsb rhs.isEmpty
    end.
  Definition next (t : T) (s:state) : list state :=
      (* filtermap com step_nt e [s]. *)
      (*reg_grammar.step_nt (reg_grammar.rules g) t s. *)
    reg_grammar.step (reg_grammar.rules g) t (filterMap id [s]).

  (* Gets all states from the set of nonterminal symbols *)
  (* The resulting states in the NFA are the nonterminal symbols of the grammar *)
  Fixpoint get_all_nt (nt: list (NT)) : list (option NT) :=
  match nt with
  | [] => []
  | a::t => [Some a] ++ get_all_nt t 
  end |> nodup equiv_dec.

  (* Adds None as a valid final state if there is a rule of the kind 
    (A,Single x) in the grammar's rules set. *)
  Definition build_nfa_from_grammar := 
  if (existsb (fun x => match x with
                        | pair A B => match B with
                                      | Single x => true
                                      | _ => false
                                      end
                        end) (reg_grammar.rules g ))
  then nfa.NFA (init) (final) (next) 
  (set_add equiv_dec (None)
  (get_all_nt (reg_grammar.nonterminal_symbols g))) 
  (reg_grammar.terminal_symbols g)
  else nfa.NFA (init) (final) (next) (get_all_nt (reg_grammar.nonterminal_symbols g)) 
  (reg_grammar.terminal_symbols g).

  Lemma grammar_to_nfa_sound_aux : forall s, forall a, nfa.step build_nfa_from_grammar s a = 
    reg_grammar.step (reg_grammar.rules g) a (filterMap id s).
  Proof. induction s.
  - unfold reg_grammar.step. simpl. auto.
  - intros. simpl. destruct a. simpl. destruct build_nfa_from_grammar. Admitted.
  Lemma same_initial_state :  Some (reg_grammar.start_symbol g) = 
  nfa.initial_state (build_nfa_from_grammar).
  Proof.  unfold build_nfa_from_grammar. destruct existsb;reflexivity.
  Qed.
  Check nfa.next build_nfa_from_grammar.
  Check reg_grammar.step.
  Definition grammar_to_nfa_aux : forall l, forall s,
  reg_grammar.is_final (reg_grammar.rules g)
    (reg_grammar.parse' (reg_grammar.rules g) l
      s) =
  nfa.verify_final_state' build_nfa_from_grammar
    (nfa.run' build_nfa_from_grammar l
      s).
  Proof.
  induction l. 
  destruct s.
  - simpl. reflexivity.
  - simpl. unfold build_nfa_from_grammar.
    + destruct existsb;reflexivity;simpl;reflexivity.
  - simpl. intros. rewrite IHl. rewrite grammar_to_nfa_sound_aux. reflexivity.
  Qed.

  (*lemma : dfa.is_final m (dfa.run' (dfa.next m) l (s)) =
  nfa.verify_final_state' (dfa.dfa_to_nfa) (nfa.run' (dfa.dfa_to_nfa) l [s]).*)
  (*is_final m (run' (next m) l (next m s a)) =
nfa.verify_final_state' dfa_to_nfa (nfa.run' dfa_to_nfa l [next m s a])
*)

  Definition grammar_to_nfa_sound : forall l,
  reg_grammar.parse g l = nfa.run (build_nfa_from_grammar) l.
  Proof.
  unfold reg_grammar.parse. unfold nfa.run. rewrite same_initial_state.
  induction l.
  - simpl. unfold build_nfa_from_grammar. destruct existsb;reflexivity.
  - apply grammar_to_nfa_aux. Qed.

  End grammar_to_nfa. 
End grammar_to_nfa.

Module nfa_epsilon_transitions.

  (* We define an inductive type for the transitions of the NFA with epsilon transitions *)
  Inductive ep_trans S A :=
  (* the incoming state is defined in the next function *)
  | Epsilon : S -> ep_trans S A
  | Goes :  A -> S -> ep_trans S A.

  (*Where Epsilon is the epsilon transitions and Goes the other transitions of the NFA*)
  Arguments Epsilon {_} {_} _.
  Arguments Goes {_} {_} _ _.
  Module exports.
      Notation Epsilon := Epsilon.
      Notation Goes := Goes.
  End exports.
End nfa_epsilon_transitions.

(* A equality decision procedure for the types of the transitions of the NFA with *)
(* epsilon transitions                                                            *)
Import nfa_epsilon_transitions.exports.
Program Instance ep_trans_eqdec S A `(EqDec S eq) `(EqDec A eq) : 
EqDec (nfa_epsilon_transitions.ep_trans S A) eq :=
{
  equiv_dec x y :=
    match x, y with
    | Epsilon x, Epsilon y => if x == y then in_left else in_right
    | Goes a b , Goes c d => if a == c then
                                if b == d then in_left else in_right
                             else in_right
    | Epsilon x, Goes y z | Goes y z, Epsilon x => in_right 
    end
}.

Module nfa_epsilon.
  Section nfa_epsilon.
  Variables A ST: Type.
  Context `{EqDec ST eq} `{EqDec A eq}.

  (* We define an NFA with epsilon transitions as the same record of a NFA, only with *)
  (* the transition relation prepared to include epsilon transitions *)
  Record t := NFA_e {
    initial_state : ST;
    is_final : ST -> bool;
    next : ST -> set (nfa_epsilon_transitions.ep_trans ST A); 
    states : set ST;
    alphabet : set A
  }.
  (* Obligation Tactic := intros. *)
  (* idea: each state has a set of (possible) transitions *)
  (* from epsilons we calculate the epsilon closure *)
  (* the other ones are normal transitions of a NFA *)
  (* we get all resulting states w
   epsilon transitions from one given state *)
  (* Program fixpoint? *)
  (* Obligation Tactic := compute. *)
  Program Fixpoint next_state_w_e
  (t: set (nfa_epsilon_transitions.ep_trans ST A)) : set ST :=
  match t with
  | [] => []
  | a::y =>
            match a with
            | Epsilon x => set_add equiv_dec (x) (next_state_w_e y)
            | _ => next_state_w_e y
            end
  end.

  (*get all transitions of a given set of states that are not epsilon transitions *)
  Fixpoint get_goes_transitions 
  (t: set (nfa_epsilon_transitions.ep_trans ST A))  :=
  match t with
  | [] => []
  | a::f => match a with 
            | Goes x y => set_add equiv_dec (Goes x y) (get_goes_transitions f)
            | Epsilon x => (get_goes_transitions f)
            end
  end.

  (* idea: extract a NFA with no epsilon transitions from one with epsilon transitions,*)
  (* storing all transitions in an intermediate set *)
  (*Creates pair of transitions (S, transition) where S is the state where the *)
  (* transition is "leaving"                                                   *)

  Context `{EqDec (nfa_epsilon_transitions.ep_trans A ST) eq}.
  Fixpoint create_transition (x:ST) (s:set (nfa_epsilon_transitions.ep_trans ST A))
  :=
  match s with
  | [] => [] 
  | a::t => set_add equiv_dec ((x,a)) (create_transition x t)
  end. 

  (* Let us define a NFA with epsilon transitions: *)
  Variable m: nfa_epsilon.t.

  (* Then we have to apply this condition to every state in the NFA: *)
  (* We define a search procedure that reaches all states of the NFA: *)
  Fixpoint bounded_search (n:nat) (x y: ST) :=
  match n with
  | O => if x == y then true else false
  | S k => if x == y then true else
            existsb (fun x => bounded_search k x y) 
                    (next_state_w_e (nfa_epsilon.next m x))
  end.


  Fixpoint get_all_reachable_states_w_e (x:ST) (s: set ST): set ST :=
  match s with
  | [] => []
  | a::t => if (bounded_search (length(nfa_epsilon.states m))(x) a)
               then set_add equiv_dec (a) (get_all_reachable_states_w_e x t)
            else get_all_reachable_states_w_e x t
  end.

  (* Calculates the epsilon closure of a given state *)
  Definition epsilon_clos (x:ST) := get_all_reachable_states_w_e x 
                          (nfa_epsilon.states m). 
  (* Gets all transitions that aren't epsilon transitions from the neighborhood  *)
  (* of a state                                                                  *)
  Definition next_from_state (x: ST) := get_goes_transitions (nfa_epsilon.next m x).
 
  (* Gets all transitions that aren't epsilon transitions from a set of *)
  (* states                                                             *)
  Definition next_from_states (s: set ST) :=
    flat_map (next_from_state) s.

  (* To make a run on a nfa with epsilon transitions, we first convert    *)
  (* it to a conventional NFA : By calculating the epsilon closure of a   *)
  (* state, we remove the epsilon transitions of the NFA                  *)
  (* This function calculates the epsilon closure for all states in a set *)
  (* of states                                                            *)
  (* With the epsilon closure of a state, we can extract the next from the NFA:*)
  Fixpoint next_from_epsilon_clos (x:set ST) :=
  match x with
  | [] => []
  | a::t => set_union equiv_dec 
            (epsilon_clos a |> next_from_states |> create_transition a)
            (next_from_epsilon_clos t)
  end.


  (* To make a run on a nfa with epsilon transitions, we first convert    *)
  (* it to a conventional NFA : By calculating the epsilon closure of a   *)
  (* state, we remove the epsilon transitions of the NFA appyling the algo*)
  (* rithm of converting a NFA with epsilon transitions to a "normal" NFA   *)

  (* This function calculates the epsilon closure and extracs all transitions:   *)
  (* defined for a given symbol of the NFA's alphabet for every state in the     *)
  (* NFA's set of states                                                         *)
  (* Definition next_nfa := next_from_epsilon_clos (nfa_epsilon.states m).       *)
  Definition next_nfa := Eval vm_compute in (next_from_epsilon_clos (nfa_epsilon.states m)).

  (* The next step is to retrieve from the "next_nfa" function all states *)
  (* that has s as the outgoing state with a                              *)
  (* The next function retrieves those states                             *)
  Fixpoint step (s:ST) (a:A)
  (x:set (ST * nfa_epsilon_transitions.ep_trans ST A)) :=
  match x with
  | [] => []
  | l::l' => match l with
             | (k,o) => if s == k then
                        match o with
                        | Goes i j => if i == a then set_add equiv_dec (j)
                                                (step s a l')
                                                else (step s a l')
                        | _ =>  (step s a l')
                        end
                        else  (step s a l')
             end
  end.

  Check step.
  (* Therefore, the function below converts the transitions to a NFA with no  *)
  (* epsilon rules                                                            *)
  Definition step_nfa (a:A) (s:ST) : set ST :=
    step s a next_nfa.

  (* Now one can create a NFA without epsilon transitions from a NFA with *)
  (* epsilon transitions                                                  *)

  Definition nfa_e_to_nfa := nfa.NFA (nfa_epsilon.initial_state m) 
  (nfa_epsilon.is_final m) (step_nfa) (nfa_epsilon.states m) (nfa_epsilon.alphabet m).
  

  End nfa_epsilon.
End nfa_epsilon.

(*Equality decision procedure of elements of the type of the transitions of a epsilon NFA *)
Program Instance eptrans_eqdec A B `(EqDec A eq) `(EqDec B eq) :
 EqDec (nfa_epsilon_transitions.ep_trans A B) eq :=
{
  equiv_dec x y :=
    match x,y with
      |Goes a b, Goes c d => if a == c then 
                                if b == d then in_left
                                else in_right
                             else in_right
      | Epsilon x, Epsilon b => if x == b then in_left else in_right
      | Goes a b, Epsilon z | Epsilon z, Goes a b => in_right
    end
}.

Module dfa.
  Section dfa.
    Variables S A: Type.
    Context  `{EqDec S eq} `{EqDec A eq}.

    Record t := DFA {
      initial_state : S;
      is_final : S -> bool;
      next : S -> A -> S;
      states: set S;
      alphabet: set A
    }.

    (*run' is the function that does the verification steps of the automata, applying     *)
    (*the transition functions in the list of terminal symbols, returning a state, which can*)
    (*be final or not.                                                                    *)
    (*acc is a accumulator, a variable that stores the result of the processing upon each ele-*)
    (* ment of the list of terminal symbols. In this case, it receives the result of applying a*)
    (*transition function for each of the elements of the list (if possible). using the fold_left iterator*)

    Definition run' (step: S -> A -> S) (l : list A) (acc : S) : S :=
      fold_left step l acc.
    Definition run (m : t) (l : list A) : bool :=
      is_final m (run' (next m) l (initial_state m)).
    Definition run2 (m :t) (l : list A) : S :=
      run' (next m) l  (initial_state m).

    Definition get_trace (m:t) : list A ->  S -> list S -> list S:=
      fix rec l s res :=
        match l with
        | [] => res
        | t::l => (res ++ [next m s t]) |> rec l (next m s t)
        end.
    Definition path (m:t) (l:list A) : list S :=
      get_trace m l (initial_state m) [initial_state m] (*|> nodup equiv_dec*).

  (* Building a grammar from a DFA. *)

  (* Gets all derivation rules from a given state *)
  Fixpoint get_transitions_from_a_state (m:t) (s: S) (l2: set A): 
  set (S * rhs.t A S):=
  match l2 with
    | [] => []
    | a::x =>  set_add equiv_dec ((s, Continue a (dfa.next m s a)))
               (get_transitions_from_a_state m s x)
  end.
  (* Gets all nonempty derivation rules from all states of the automaton *)
  Fixpoint add_rules (m:t) (l1: set S) (l2: set A)
  : set (S * rhs.t A S) :=
  match l1 with
  | [] => []
  | a::t => set_union equiv_dec
            (get_transitions_from_a_state m a l2)(add_rules m t l2)
  end.

  (* Gets all empty rules of the resulting grammar for a given nonterminal *)
  Fixpoint get_empty_rules (m:t) (s: S) (l2: set A): set (S * rhs.t A S) :=
  match l2 with
  | [] => []
  | a::x => if (is_final m (dfa.next m s a)) then
            set_add equiv_dec ((dfa.next m s a, Empty)) (get_empty_rules m s x)
            else get_empty_rules m s x
  end.

  (* Gets all empty rules of the resulting grammar for all nonterminals*)
  Fixpoint add_empty_rules (m:t) (l1: set S) (l2: set A)
  : set (S * rhs.t A S) :=
  match l1 with
  | [] => []
  | a::t => set_union equiv_dec (get_empty_rules m a l2) (add_empty_rules m t l2)
  end.

  Definition dfa_transitions_to_grammar_rules (m:t) (l1:set S) (l2:set A) := 
   set_union equiv_dec
  (add_rules m l1 l2) (add_empty_rules m l1 l2) .


  Definition dfa_to_regular_grammar (m:t): reg_grammar.g A S :=
    reg_grammar.build_grammar (initial_state m) 
    (dfa_transitions_to_grammar_rules m (dfa.states m) (dfa.alphabet m))
    (dfa.alphabet m) (dfa.states m).


  (* We can build an NFA from a DFA. *)
  Variable m : t.
  (* The first step is to rewrite the next function of the DFA as the same way it behaves for the NFA*)
  Definition nfa_step(t:A) (s:S) :=
    [dfa.next m s t].

  Definition dfa_to_nfa := nfa.NFA (dfa.initial_state m) (dfa.is_final m)
  (nfa_step) (dfa.states m) (dfa.alphabet m).


  (* We can also build a regular grammar from a DFA: *)
  (* Verifying if the DFA is a minimal DFA.                                   *)
  (* idea: a DFA is minimal iff there is no equivalent transition             *)
  (* The first step is to check whether a pair of states is equivalent:       *)
  Program Fixpoint check_pair_states (m:t) (s1: S) (s2: S) (l: set A) : bool := 
    match l with
    | [] => true
    | a::t => if (((dfa.next m s1 a) == (dfa.next m s2 a))) 
              then check_pair_states m s1 s2 t
              else false
    end.
  Check check_pair_states.

  Fixpoint check_a_pair_states (m:t) (s1: S) (s2: list S) (l:list A) : bool :=
    match s2 with
    | [] => false
    | b::y => if s1 <> b then
                   if (check_pair_states m s1 b l == false)
                   then check_a_pair_states m s1 y l
                   else true
              else check_a_pair_states m s1 y l
    end.

  (* Then we can check for all states of the automaton if there is no equivale-*)
  (* nt state in the automaton.                                                *)
  Definition has_equivalent_states (m:t): set S -> set S -> set A -> bool :=
    fix rec s1 s2 l :=
      match s1 with
      | [] => false
      | a::t => check_a_pair_states m (a) s2 l || rec t s2 l
    end.

  Definition is_minimal (m:t) :=
    negb (has_equivalent_states  m (dfa.states m) (dfa.states m) (dfa.alphabet m)).

  (* We can also return the pair of states that are equivalent *)
  Fixpoint get_equivalent_states (m:t) (s1: S) (s2: set S) (l:set A) : set (S * S) :=
    match s2 with
    | [] => []
    | b::y => if s1 <> b then
                   if (check_pair_states m s1 b l == true)
                   then set_add equiv_dec ((s1,b)) (get_equivalent_states m s1 y l)
                   else get_equivalent_states m s1 y l
              else get_equivalent_states m s1 y l
    end.

  Definition get_all_equivalent_states (m:t): set S -> set S -> set A -> set (S * S) :=
    fix rec s1 s2 l :=
      match s1,s2 with
      | [],[] => []
      | a::t,x::y => set_union equiv_dec (get_equivalent_states m (a) s2 l)
                    (rec t y l)
      | _,_ => []
    end.

  (* Top level function that returns pairs of equivalent states *)
  Definition check_equivalent_states (m:t) :=
    get_all_equivalent_states m (dfa.states m) (dfa.states m) (dfa.alphabet m).

  End dfa.
End dfa.

Module nfa_to_dfa.
  Section nfa_to_dfa.

  Variables A ST : Type.
  Context `{EqDec A eq} `{EqDec ST eq}.
  Variable m: nfa.t A ST.
 
  (* We implement the conversion of NFA to DFA using the powerset construction          *)
  (* algorith on the fly. Then, a state in the DFA is built according to the algorithm. *)
  Definition state := set ST.
  (*The initial state of the DFA is the same of the NFA. *)
  Definition init : state := [nfa.initial_state m].
  (*The final states of the DFA will be the states that were built from at least*)
  (* one final state of the NFA                                                 *)
  Definition final (s : state) : bool :=
    nfa.verify_final_state' (m) s.
  Definition dfa_alphabet := nfa.alphabet m.
  Definition dfa_next (s:state) (a:A) : state := nfa.step m s a.

  (* Gets all next states from a given state *)
  Fixpoint list_states (s:state) (l: set A) :  set state :=
    match l with
    | [] => []
    | a::t => if (dfa_next s a <> []) then
              set_add equiv_dec (dfa_next s a) (list_states s t)
              else list_states s t
    end.

  (* We compute the powerset of the states of the NFA : *)
  Definition power_states := powerset (nfa.states m).

  (* And we want only the states in the powerset that are reachable from the *)
  (* initial state:                                                          *)
  Fixpoint bounded_search (n:nat) (x y: state) :=
  match n with
  | O => set_eq x y
  | S k => if (set_eq x y) then true else
            existsb (fun x => bounded_search k x y) (list_states x (nfa.alphabet m))
  end.

  Fixpoint get_all_reachable_states (s: set state): set state :=
  match s with
  | [] => []
  | a::t => if (bounded_search (length(nfa.states m)) ([nfa.initial_state m]) a)
            then set_add equiv_dec (a) (get_all_reachable_states t)
            else get_all_reachable_states t
  end.

  (* The resulting set of states are all states within the powerset that are *)
  (* reachable from the initial state of the DFA                             *)
  Definition dfa_states := get_all_reachable_states (power_states).
  Definition build_dfa_from_nfa := dfa.DFA (init) (final) (dfa_next) (dfa_states)
    (dfa_alphabet).

  End nfa_to_dfa. 
End nfa_to_dfa.

(* We can also explicitly construct a DFA corresponding to the grammar. In fact, all
   the hard work was already done in our grammar parser. *)
Module powerset_construction.
  Section powerset_construction.

    Variable T NT : Type.
    Context `{EqDec T eq} `{EqDec NT eq}.
    (*a valid regular grammar shall follow the rules of g, where T and NT are, respectively, *)
    (* the terminal and nonterminal symbols.                                                 *)
    Variable g : reg_grammar.g T NT.
    Definition state : Type := set (option NT).
    (* The automata's inital state is the same as the start symbol of the grammar.           *)

    Definition init : state := [Some (reg_grammar.start_symbol g)].
    (*The same goes to a final state in the automaton. *)
    Definition is_final (s : state) : bool :=
      reg_grammar.is_final (reg_grammar.rules g) s.
    Definition next (s : state) (t : T) : state :=
      reg_grammar.step (reg_grammar.rules g) t (filterMap id s).

    Definition alphabet := (reg_grammar.terminal_symbols g).


    (*Gets nonterminal symbols and converts them to the same type of the states of the resulting  *)
    Fixpoint nt_to_state (l : set NT) : set (option NT) :=
    match l with
      | [] => []
      | a::t => set_add equiv_dec (Some a) (nt_to_state t)
    end.

    Definition states :=
      if (existsb (fun x => match x with
                          | pair A B => match B with
                                        | Single x => true
                                        | _ => false
                                        end
                          end) (reg_grammar.rules g ))
    then set_add equiv_dec (None) (nt_to_state (reg_grammar.nonterminal_symbols g))
    else (nt_to_state (reg_grammar.nonterminal_symbols g)).

    (* Again, We compute the powerset of the states of the NFA (created "on the fly" from the grammar: *)
    Definition power_states := powerset states.

    (* Gets all reachable states from the state s *)
    Fixpoint list_states (s:state) (l: set T) :  set state :=
      match l with
      | [] => []
      | a::t => if (next s a <> []) then
                set_add equiv_dec (next s a) (list_states s t)
                else list_states s t
      end.

    (* And we want only the states in the powerset that are reachable from the *)
    (* initial state:                                                          *)
    Fixpoint bounded_search (n:nat) (x y: state) :=
    match n with
    | O => if set_eq x y then true else false
    | S k => if set_eq x y then true else
              existsb (fun x => bounded_search k x y) (list_states x (reg_grammar.terminal_symbols g))
    end.

    Fixpoint get_all_reachable_states (s: set state): set state :=
    match s with
    | [] => []
    | a::t => if (bounded_search (length (reg_grammar.nonterminal_symbols g)) 
                  ([Some (reg_grammar.start_symbol g)]) a)
              then set_add equiv_dec (a) (get_all_reachable_states t)
              else get_all_reachable_states t
    end.

   Definition build_dfa := 
   dfa.DFA (init) (is_final) (next) 
   (get_all_reachable_states (power_states))
    (reg_grammar.terminal_symbols g).

  End powerset_construction.
End powerset_construction. 

Require Export List.
Export ListNotations.
Require Export Classes.EquivDec.
Require Export Coq.Program.Program.
Require Export Bool.
Require Export ListSet.
