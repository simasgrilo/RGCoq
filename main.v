Require Import List.
Import ListNotations.
Require Import Classes.EquivDec.
Require Import Coq.Program.Program.
Require Import Bool.

(*leave the type inference at maximum level in Coq, not being necessary to declare the type*)
(*of parameters of functions, as seen in https://coq.inria.fr/cocorico/CoqNewbieQuestions *)

Set Implicit Arguments.
(*Coq will try to infer at maximum level the arguments' types *)
Set Maximal Implicit Insertion.

(* First, some library helper functions and notations. *)
(* https://coq.inria.fr/distrib/current/refman/Reference-Manual023.html#hevea_command261/ *)
(*Instance: in this case, the Instance keyword creates a instance of the EqDec class,i.e, *)
(*creates an instance of an equality relation for the type option A (A: Type)             *)
(*Program : gives a way to write programs as if they were written in a regular functional *)
(*programming language, such as Haskell, using the Coq proof apparatus to generate a sound*)
(*program from the specification given.                                                   *)

(*eq: equality relation, it is an inductive proposition that gives the notion of equality *)
(*between 2 elements of the same type. It is in Coq.Init.Logic.                           *)

Obligation Tactic := unfold complement, equiv ; program_simpl.
(*needed tactic, so the obligations generated by Program to deal with the proof of the sound*)
(*ness is solved automatically by the Program keyword.                                     *)

Program Instance option_eqdec A `(EqDec A eq) : EqDec (option A) eq :=
{
  equiv_dec x y :=
    match x, y with
      | Some a, Some b => if a == b then in_left else in_right
      | None, None => in_left
      | Some _, None | None, Some _ => in_right
    end
 }.

Definition filterMap {A B} (f : A -> option B) : list A -> list B :=
  fix rec (l : list A) : list B :=
    match l with
    | [] => []
    | x :: l => match f x with
               | None => rec l
               | Some y => y :: rec l
               end
    end.

Notation "x |> f" := (f x) (left associativity, at level 69, only parsing).

(* A type representing valid right-hand sides of left-regular grammar rules.
   The original email used a much looser representation of rules, which did not
   separate the LHS from the RHS, and which did not enforce regularity. By
   restricting the representation, we make it easier to write a parser. *)
Module rhs.
  (*RHS: Right Hand Side: How right linear regular grammar should behave:its rules should*)
  (*be A -> a, A -> a B or A -> e, where A and B denotes nonterminal symbols and a denotes.*)
  (* a terminal symbol.                                                                   *)
  Variables T NT : Type.
  Inductive t T NT :=
  | Empty : t T NT
  | Single : T -> t T NT
  | Continue : T -> NT -> t T NT.


  (* Coq will infer the type of the arguments of the constructors of the RHS type, as seen in *)
  (*https://coq.inria.fr/distrib/current/refman/Reference-Manual004.html#hevea_command59      *)
  (* so we don't have to worry about expliciting the types every now and then. *)

  Arguments Empty {_} {_}.
  Arguments Single {_} {_} _.
  Arguments Continue {_} {_} _ _.
  (*the function below checks whether a rule is empty or not, given the terminal and nonterminal    *)
  (*and the RHS of a rule, returns true if this RHS is Empty, otherwise, returns false        *)
  Definition isEmpty (T NT : Type) (rhs : rhs.t T NT) : bool :=
    match rhs with
    | Empty => true
    | _ => false
    end.

  (*This function checks whether the given rhs can be used in the final process of a derivation*)
  Definition canBeFinal (T NT: Type)(rhs : rhs.t T NT) : bool :=
    match rhs with
    | Continue _ _ => false
    | _ => true
    end.

  Module exports.
    Notation Empty := Empty.
    Notation Single := Single.
    Notation Continue := Continue.
  End exports.
End rhs.
Import rhs.exports.

Module reg_grammar.
  Section reg_grammar.
    Variable T NT : Type.
    Context  `{EqDec T eq} `{EqDec NT eq}.
    (*When using this, it is possible to use the notion of equality between elements of type*)
    (* T and NT                                                                             *)
    (*graças à isso, é possível usar a noção de igualdade aqui dentro para variáveis do *)
    (*tipo T e NT *)

  Record g : Type:= {
      start_symbol: NT;
      rules : list(NT * rhs.t T NT)
  }.

  Definition build_grammar (nt: NT) rules: g :={|
      start_symbol := nt;
      rules := rules |}.

  (* Next, we're going to write a function [parse] that decides whether a string
     is in the language represented by the grammar. The parser keeps track of
     the set of nonterminal symbols it's currently in, with the additonal
     special symbol None representing "end of string when the last rule applied
     had RHS [Single]". *)

  (* It may help to scroll down to the function [parse] first, and read
     backwards up to here. *)

  (* Given the RHS of a rule and a terminal, decides whether the RHS can be used. *)
  (* In others words, given a RHS of a rule and a terminal symbol, it checks how, if it *)
  (* can be used, the RHS will be used.                                            *)
  Definition step_rhs (t : T) (rhs : rhs.t T NT) : list (option NT) :=
    match rhs with
    | Empty => []
    | Single t' => if t == t' then [None] else []
    | Continue t' nt => if t == t' then [Some nt] else []
    end.

  (* Finds all the productions for a given nonterminal. *)
  (*Note: this list will never be empty, if the nt symbol belongs to the grammar   *)
  Definition getRHS `{EqDec NT eq}
           (nt : NT) : list (NT * rhs.t T NT) ->
                       list (rhs.t T NT) :=
    filterMap (fun rule => let '(nt', rhs) := rule in
                        if nt == nt' then Some rhs else None).


  (* Given a nonterminal [nt], applies all possible rules,applying step_rhs on the             *)
  (* list of nonterminal symbols obtained by applying getRHS nt with the rules of the grammar  *)
  Definition step_nt (rules : list(NT * rhs.t T NT)) (t : T) (nt : NT) : list (option NT) :=
    rules |> getRHS nt  |> flat_map (step_rhs t).


  (* Given a *list* of nonterminals, takes all possible next steps. *)
  (*map: returns 1 value for each application of the function for each element of the list. *)
  (*flat_map: returns 0 or more values for each application of the function in each list element.*)
  (*if applyable *)
  Definition step (rules : list(NT * rhs.t T NT)) (t : T) (acc : list NT) : list (option NT) :=
  acc |> flat_map (step_nt rules t) |> nodup equiv_dec.


  (* The main parser loop. Repeatedly steps the current set of states using
     terminals from the string. *)
  Definition parse' (rules : list(NT * rhs.t T NT))
           : list T -> list (option NT) -> list (option NT) :=
    fix rec l acc :=
      match l with
      | [] => acc
      | t :: l =>
    (*filtermap id : acc gets the elements of t::l. *)
        acc |> filterMap id
            |> step rules t
            |> rec l
      end.
  (* Checks to see if the current state represents an accepting state.  In this
     representataion of state, a state is accepting if it contains [None] or if
     it contains [Some nt] and there is a rule [(nt, Empty)].  *)
  Definition is_final (rules : list (NT * rhs.t T NT)) (l : list (option NT)) : bool :=
  (*existsb: boolean exists, chech whether a condition can
  be met by any of the elements in l*)
  (*This function is in Coq.Lists, where o is an element of the list l.*)
  (* Note that the order of the elements in this list does not affect the result,*)
  (* because for all elements of the list it is checked whether a state is final *)
  (*according to the rules.                                                      *)

    existsb (fun o => match o with
                   | None => true
                   | Some nt => getRHS nt rules |> existsb rhs.isEmpty
                   end)
            l.
  (* Top-level parse function. Calls [parse'] with the initial symbol and checks
     to see whether the resulting state is accepting. *)
  Definition parse (grammar : reg_grammar.g) (l : list T): bool :=
    [Some (start_symbol grammar)] |> parse' (rules grammar) l |> is_final (rules grammar).


(* vacation *)

  (* Get all nonterminal symbols from a grammar *)
  Fixpoint get_all_nt (rules: list (NT * rhs.t T NT)) : list NT :=
  match rules with
  | [] => []
  | a::t => [(fst a)] ++ get_all_nt t 
  end |> nodup equiv_dec.

  (* Get all terminal symbols that can be used by a given nt         *)
   Fixpoint get_all_t_nt (rules: list (NT * rhs.t T NT)) (nt:NT) : list T :=
   match rules with
   | [] => []
   | a::t => match snd a with
             |Empty => []
             |Single x => if (fst a) == nt then [x] else []
             |Continue x _ => if (fst a) == nt then [x] else []
            end
            ++ (get_all_t_nt t nt)
  end |> nodup equiv_dec.

  Definition get_t_from_rhs(rhs:rhs.t T NT): list T :=
  match rhs with
    |Empty => []
    |Single x => [x] 
    |Continue a _ => [a]
  end.


  Definition get_nt_from_rhs(rhs:rhs.t T NT): list NT :=
  match rhs with
    |Continue _ x => [x]
    | _ => []
  end.

  (* This function is a part of the minimization algorithm. In this case, it gets all possible *)
  (* terminals symbols from the grammar to check whether a given state is reachable            *)
  Definition get_all_possible_t : list(NT * rhs.t T NT) -> list T :=
  fix rec l :=
    match l with
      |[] => []
      |a::t => get_t_from_rhs (snd a) ++  rec t
    end  |> nodup equiv_dec.

   (* Get all states that can be reachable from a state *)
  Definition get_all_states (rules:list(NT * rhs.t T NT)) (nt: NT): list T -> list (option NT):=
  fix rec l := 
    match l with
      |[] => []
      | c::d => (reg_grammar.step_nt rules c nt) ++ rec d 
    end |> nodup equiv_dec.

  (* further development: minimization algorithm *)
  (*
  (*the minimization of a automaton built from a grammar can be done upon the very grammar *)
  (* which the automaton is built, getting all pair of states and marking 1 if they   *)
  (* can't be equivalent (nonfinal, final) and 0 otherwise:                                *)
  Fixpoint build_tabular(g: reg_grammar.g)(s:NT) (l: list NT) : list ((NT * NT) * nat) :=
    match l with
    |[] => []
    | a::t => if (s <> a) then
              match (getRHS s (rules g)|> existsb rhs.canBeFinal), getRHS a (rules g)|> existsb rhs.canBeFinal with
                | true,false => [((s,a),1)]
                | false,true => [((s,a),1)]
                | _,_        => [((s,a),0)]
              end
                  ++ build_tabular g s t
             else build_tabular g s t
  end.

  (* We build the table for all pair of states *)
  Fixpoint build_full_table (g: reg_grammar.g)(l1: list NT) (l2: list NT) : list ((NT * NT) * nat) :=
  match l1 with 
  | [] => []
  | a::t => build_tabular g a l2 ++ build_full_table g t l2
  end.

  (*then we have to check whether, for a given pair of states, for all terminal symbols  *)
  (* if they go to the same states, these states are equivalent.                         *)
  (* First, for a given pair of states, let us check if, for a terminal symbol, where it *)
  (* is headed.                                                                          *)

  (* Bugged : needs to get rid of the option NT step_nt returns                          *)
  (*Definition pair_step (rules: list (NT * rhs.t T NT))(p: ((NT * NT) * nat)) (t : T) : 
  (NT * NT) * nat :=
  ( (reg_grammar.step_nt (rules) t (fst(fst p))|> filterMap id),(reg_grammar.step_nt (rules) t (snd(fst p))),0).
  *)

  *)

  End reg_grammar.
End reg_grammar.

(* Nondeterministic finite automata (incomplete) *)
Module nfa.
  Section nfa.
    Variable (S A T NT L: Type).
    Context  `{EqDec S eq} `{EqDec A eq}.
    (*colocar um campo is_deterministic que me diz se dado o conjunto de funções, o autômato*)
    (* é não deterministico? *)
    (* Seria melhor uma forma de extrair a função "next" de dentro da lista de regras? *)
    (* ideia: diferente do DFA, tratar os estados de um NFA como uma lista de possíveis estados. *)
    (* the difference between NFAs and DFAs is that we treat them now as having a list of "possible
    (* states" that from a given state and a terminal symbol it can go. *)
    Record t := NFA {
      initial_state : S;
      is_final : list S -> bool;
      next : list S -> A -> list S;
      (* The syntax of the transition rules follows the same idea as for the grammars. *)
      transition_rules : list(list S * rhs.t A (list S))
      (*states : list S;*)
      (*maybe it will be necessary to store the list of states for the minimization algorithm*)
   }.

    (*run' is the function that does the verification steps of the automata, applying     *)
    (*the transition functions in the list of terminal symbols, returning a state, which can*)
    (*be final or not.                                                                    *)

    (*acc is a accumulator, a variable that stores the result of the processing upon each ele-*)
    (* ment of the list of terminal symbols. In this case, it receives the result of applying a*)
    (*transition function for each of the elements of the list (if possible). using the fold_left iterator*)

    Definition run' (step: list S -> A -> list S) (l : list A) (acc : list S) : list S :=
      fold_left step l acc.
    Definition run (m : t) (l : list A) : bool :=
      is_final m (run' (next m) l ([initial_state m])).
    Definition run2 (m :t) (l : list A) : list S :=
      run' (next m) l  ([initial_state m]).

  End nfa.
End nfa.

Module dfa.
  Section dfa.

    Variable (S A L: Type).
    Context  `{EqDec S eq} `{EqDec A eq}.
    Record t :Type := DFA {
      initial_state : S;
      is_final : S -> bool;
      next : S -> A -> S;
      (* The syntax of the transition rules follows the same idea as for the grammars. *)
      transition_rules : list(S * rhs.t A S)
      (*states : list S;*)
      (*maybe it will be necessary to store the list of states for the minimization algorithm*)
    }.

    (*run' is the function that does the verification steps of the automata, applying     *)
    (*the transition functions in the list of terminal symbols, returning a state, which can*)
    (*be final or not.                                                                    *)
    (*acc is a accumulator, a variable that stores the result of the processing upon each ele-*)
    (* ment of the list of terminal symbols. In this case, it receives the result of applying a*)
    (*transition function for each of the elements of the list (if possible). using the fold_left iterator*)

    Definition run' (step: S -> A -> S) (l : list A) (acc : S) : S :=
      fold_left step l acc.
    Definition run (m : t) (l : list A) : bool :=
      is_final m (run' (next m) l (initial_state m)).
    Definition run2 (m :t) (l : list A) : S :=
      run' (next m) l  (initial_state m).
    (* further work  *)
    (* Minimization of a DFA *)

    Fixpoint build_tabular(m:t)(s:S) (l: list S) : list ((S * S) * nat) :=
      match l with
      |[] => []
      | a::t => if (s <> a) then
                  match is_final m s, is_final m a with
                  | true,false => [((s,a),1)]
                  | false,true => [((s,a),1)]
                  | _,_        => [((s,a),0)]
                  end
                  ++ build_tabular m s t
                else build_tabular m s t
  end.

  (* One can build the table for all pair of states from a manually built automaton *)
  Fixpoint build_full_table (m:t)(l1: list S) (l2: list S) : list ((S * S) * nat) :=
  match l1 with 
  | [] => []
  | a::t => build_tabular m a l2 ++ build_full_table m t l2
  end.

  (* Since DFAs are NFAs with a "restriction" in the set of rules, we can easily create a *)
  (* NFA from a DFA in a way that does not change the original automata's language: given *)
  (* a list of rules, we just create another rule from the start symbol that goes to ano- *)
  (* ther nonterminal symbol which is not final (so it doesn't change the language of the *)
  (* automata)                                                                            *)
  (* Definition dfa_to_nfa (dfa: dfa.DFA) :=                                              *)

  (*
  Definition dfa_to_nfa (dfa: dfa.t ): nfa.t S A:= {|
      nfa.initial_state := (dfa.initial_state dfa);
      nfa.is_final := (dfa.is_final dfa );
      nfa.next := (dfa.next dfa);
      nfa.transition_rules := (dfa.transition_rules dfa)
   |}. *)

  End dfa.
End dfa.


(* We can explicitly construct a DFA corresponding to the grammar. In fact, all
   the hard work was already done in our grammar parser. *)

(* tem um lance aqui : esse cara aceita nfa também ( falar com bruno ) OK, solucionar abaixo:*)

(* TODO Próximo passo: sumir com a diferença entre NFA e DFA: caso seja possível, criar o DFA
Senão é um NFA (isso no mesmo módulo). em seguida, é necessário armazenar a lista de regras
de transição a fim de se obter uma prova que o autômato é determinístico ou não. O mó
dulo dfa deve virar o módulo finite_automata. quase OK *)

Module powerset_construction.
  Section powerset_construction.
    (* Na verdade, essa é a passagem de um NFA para um DFA *)
    Variable T NT : Type.
    Context `{EqDec T eq} `{EqDec NT eq}.
    (*a valid regular grammar shall follow the rules of g, where T and NT are, respectively, *)
    (* the terminal and nonterminal symbols.                                                 *)
    Variable g : reg_grammar.g T NT.
    Definition state : Type := list (option NT).
    (* The automata's inital state is the same as the start symbol of the grammar.        *)

    Definition init : state := [Some (reg_grammar.start_symbol g)].
    (*The same goes to a final state in the automaton. *)
    Definition is_final (s : state) : bool :=
      reg_grammar.is_final (reg_grammar.rules g) s.
    Definition next (s : state) (t : T) : state :=
      reg_grammar.step (reg_grammar.rules g) t (filterMap id s).

    (*Definition alphabet := reg_grammar.get_all_possible_t (reg_grammar.rules g).*)


    Fixpoint list_state (rules: list(NT * rhs.t T NT))  : list state :=
      match rules  with
      | [] => []
      | a::t => [[Some (fst a)]] ++ list_state t 
      end |> nodup equiv_dec. 


    Definition build_dfa_rule (s: state) (t: T) : list (state * rhs.t T state) :=
    [(s, Continue t (powerset_construction.next (s) (t)))].

    Fixpoint build_rules_from_state (s:state) (l : list T) :=
    match l with
    | [] => []
    | a::r => if (powerset_construction.next (s) (a) == [])
              then build_rules_from_state s r
              else build_dfa_rule s a ++ build_rules_from_state s r
    end.

    Fixpoint get_all_rules (ls: list state) :=
    match ls with
    | [] => []
    | a::r => build_rules_from_state (a) (reg_grammar.get_all_possible_t (reg_grammar.rules g)) ++
      get_all_rules (r)
    end.

    (*Get all terminals from a given nonterminal *)
    Fixpoint get_all_t2 (rules: list (NT * rhs.t T NT)) (nt:NT) : list T :=
    match rules with
    | [] => []
    | a::t => match snd a with
              |Empty => []
              |Single x => if (fst a) == nt then [x] else []
              |Continue x _ => if (fst a) == nt then [x] else []
             end
            ++ (get_all_t2 t nt)
    end. (* nodup aqui tira o não determinimsmo *)

    (* Count the occorrences of a terminal in a list *)
    Fixpoint count (t:list T) (l: list T) : nat :=
      match l with
      | [] => 0
      | a::r => if ([a]==t) then 1 + count t r else count t r
    end.

    (* TODO provar a soundness disso e readaptar pra lista de transições do autômato. *)
    (*this function verifies wheter a given set of rules has a "nondeterministic" rule. DFAs *)
    (* can only be created iff this function returns false, where NFAs can only be created   *)
    (* iff this function returns false                                                       *)
    Definition get_nondeterminism (rules: list (NT * rhs.t T NT)) : list (NT * rhs.t T NT) -> bool :=
    fix rec r :=
      match r with
      | [] => false 
      | a::t => match (get_all_t2 rules (fst a) |> count (reg_grammar.get_t_from_rhs(snd a))) with 
                | 0 => rec t 
                | 1 => rec t
                | _ => true
                end
    end.

    Definition build_dfa := dfa.DFA (init) (is_final) (next)
   (get_all_rules (list_state (reg_grammar.rules g))).

  End powerset_construction.
End powerset_construction.

Module examples.
  Module non_terminal.
    Inductive t:Type :=
      A | B.

    Program Instance eqdec : EqDec t eq :=
      { equiv_dec x y :=
          match x, y with
          | A, A => in_left
          | B, B => in_left
          | A, B | B, A => in_right
          end
      }.
  End non_terminal.

  Module terminal.
    Inductive t : Type :=
      a | b.

    Program Instance eqdec : EqDec t eq :=
      { equiv_dec x y :=
          match x, y with
          | a, a => in_left
          | b, b => in_left
          | a, b | b, a => in_right
          end
      }.
  End terminal.

  Definition a_b_rules: list(non_terminal.t * rhs.t terminal.t non_terminal.t):=
    [(non_terminal.A, Continue terminal.a non_terminal.A);
     (non_terminal.A, Continue terminal.b non_terminal.B);
     (non_terminal.A, Empty);
     (non_terminal.B, Continue terminal.b non_terminal.B);
     (non_terminal.B, Empty)].

  Definition a_b_grammar : reg_grammar.g terminal.t non_terminal.t :=
    {| reg_grammar.start_symbol := non_terminal.A;
       reg_grammar.rules := a_b_rules |}.

  (* A few examples. *)
  Eval compute in reg_grammar.parse a_b_grammar [].
  Eval compute in reg_grammar.parse a_b_grammar [terminal.a].
  Eval compute in reg_grammar.parse a_b_grammar [terminal.a; terminal.a].
  Eval compute in reg_grammar.parse a_b_grammar [terminal.b; terminal.b].
  Eval compute in reg_grammar.parse a_b_grammar [terminal.a; terminal.b].
  Eval compute in reg_grammar.parse a_b_grammar [terminal.b; terminal.a].


  (* A hand rolled DFA for the same language. *)
  Definition a_b_next (s : option non_terminal.t) (t : terminal.t) : option non_terminal.t :=
    match s with
    | None => None
    | Some non_terminal.A =>
      match t with
      | terminal.a => Some non_terminal.A
      | terminal.b => Some non_terminal.B
      end
    | Some non_terminal.B =>
      match t with
      | terminal.a => None
      | terminal.b => Some non_terminal.B
      end
    end.

  Definition a_b_is_final (s : option non_terminal.t) : bool :=
    match s with
    | None => false
    | Some _ => true
    end.

  Definition a_b_transition_rules : list (option non_terminal.t * rhs.t terminal.t (option non_terminal.t)) :=
  [(Some non_terminal.A, Continue terminal.a (Some non_terminal.A));
     (Some non_terminal.A, Continue terminal.b (Some non_terminal.B));
     (Some non_terminal.A, Empty);
     (Some non_terminal.B, Continue terminal.b (Some non_terminal.B));
     (Some non_terminal.B, Empty)].

  Definition a_b_dfa : dfa.t _ _  :=
    {| dfa.initial_state := Some non_terminal.A;
       dfa.is_final := a_b_is_final;
       dfa.next := a_b_next;
       dfa.transition_rules := a_b_transition_rules |}.

  (*(* manual minimization test *)
  Eval compute in dfa.build_full_table a_b_dfa [Some non_terminal.A; Some non_terminal.B]  [Some non_terminal.A; Some non_terminal.B].
  *)
  (* Examples running the DFA. *)
  Eval compute in dfa.run a_b_dfa [].
  Eval compute in dfa.run a_b_dfa [terminal.a].
  Eval compute in dfa.run a_b_dfa [terminal.b].
  Eval compute in dfa.run a_b_dfa [terminal.a; terminal.a].
  Eval compute in dfa.run a_b_dfa [terminal.b; terminal.b].
  Eval compute in dfa.run a_b_dfa [terminal.a; terminal.b].
  Eval compute in dfa.run a_b_dfa [terminal.b; terminal.b;terminal.a].

  (* Automatically construct a DFA using the powerset construction. *)
  Check a_b_grammar.
  Definition a_b_dfa' := powerset_construction.build_dfa a_b_grammar.
  Check a_b_dfa'.

  (* Examples running the second DFA. *)
  Eval compute in dfa.run a_b_dfa' [].
  Eval compute in dfa.run a_b_dfa' [terminal.a].
  Eval compute in dfa.run a_b_dfa' [terminal.a; terminal.a].
  Eval compute in dfa.run a_b_dfa' [terminal.b; terminal.b].
  Eval compute in dfa.run a_b_dfa' [terminal.a; terminal.b;terminal.a].
  Eval compute in dfa.run a_b_dfa' [terminal.a; terminal.b;terminal.a].
  Eval compute in dfa.run a_b_dfa' [terminal.b; terminal.a]. 


  Inductive non_terminal1 := S| S1 | S2 | S3 |S4.
  Inductive terminal1 := a | b |c | d.

(* A hand-made NFA: under construction *)

  Definition grammar_rules: list (non_terminal1 * rhs.t terminal1 non_terminal1) :=
  [(S, Continue a S1); (S, Empty);
     (S1, Continue b S2);
     (S2, Continue c S3);
     (S3, Single d);(S3, Continue a S)].

  Program Instance eqdec : EqDec non_terminal1 eq :=
      { equiv_dec x y :=
          match x, y with
          | S,S => in_left
          | S1, S1 => in_left
          | S2, S2 => in_left
          | S3, S3 => in_left
          | S4, S4 => in_left
          | S, S1|S1,S| S, S2 | S2, S | S, S3 | S3, S | S1, S2 | S2, S1 | S1, S3 | S3, S1 
          | S2, S3 | S3, S2| S4, S | S4, S1 | S4, S2 | S4, S3| S,S4 |S1, S4| S2, S4| S3,S4 => in_right
          end
      }.
    Program Instance eqdec2 : EqDec terminal1 eq :=
      { equiv_dec x y :=
          match x, y with
          | a,a => in_left
          | b, b => in_left
          | c, c => in_left
          | d, d => in_left
          | a, b| b,a| a, c | c, a | a, d | d, a | b, c | c, b | b, d | d, b 
          | c, d | d, c => in_right
          end
      }.

   Eval compute in reg_grammar.get_all_possible_t grammar_rules.
   Eval compute in powerset_construction.get_nondeterminism grammar_rules grammar_rules.

  Definition grammar_example := reg_grammar.build_grammar S grammar_rules.
  Definition automata_example := powerset_construction.build_dfa grammar_example.
  Eval compute in dfa.transition_rules automata_example.

  Eval compute in dfa.run automata_example [a;b;c;d].
  Eval compute in dfa.run automata_example [a;b;c].
  Eval compute in dfa.run automata_example [a;b;b;c;d].
  Eval compute in dfa.run automata_example [].

  Definition rules_example_2 : list(non_terminal1 * rhs.t terminal1 non_terminal1) :=
  [(S,Continue a S1);(S, Single a);(S,Continue b S2);(S1, Continue a S1);(S1,Continue c S3);(S2,Continue b S2);
  (S2, Continue d S4);(S3, Single c);(S3,Continue c S);
  (S4, Single d);(S4,Continue d S)].

  Eval compute in powerset_construction.get_nondeterminism rules_example_2 rules_example_2.
  Eval compute in reg_grammar.getRHS S rules_example_2.

  (* An example of a NFA built from a grammar: *)
  Definition grammar_example_2 := reg_grammar.build_grammar S rules_example_2.
  Definition automata_example_2 := powerset_construction.build_dfa grammar_example_2.


  (* testing of the table for the dfa minimization *)
  (* build_full_table (m:t)(l1: list S) (l2: list S) *)
  (* looks like it works for the case of the grammar: *)
  (*  Eval compute in reg_grammar.build_full_table grammar_example_2 (reg_grammar.get_all_nt (reg_grammar.rules grammar_example_2))
  (reg_grammar.get_all_nt (reg_grammar.rules grammar_example_2)).

  Eval compute in dfa.states automata_example_2.
  Eval compute in  (powerset_construction.list_state (rules_example_2) |> filterMap id).
  Eval compute in dfa.build_tabular automata_example_2 [Some S] [(powerset_construction.list_state (rules_example_2))].
  *)
  (* ----------------------------------  *)

  Eval compute in dfa.run automata_example_2 [b;d;d]. (*returns true*)
  Eval compute in dfa.run automata_example_2 [b;d;d;c]. (*returns false*)
  Eval compute in dfa.run automata_example_2 [a;c;c]. (*returns true*)
  Eval compute in dfa.run automata_example_2 [a;c;c;b;d;d]. (*returns true*)
  Eval compute in dfa.run automata_example_2 [b;d;d;a;b;c;c].    (*returns false*)
  Eval compute in dfa.run automata_example_2 [b;b;b;b;b;b;b;d;d;a;c;c]. (*returns true*)
  Eval compute in dfa.run automata_example_2 [b;d;d;a;c;c;b;d;d;b;d;d]. (*returns true*)
  Eval compute in dfa.run automata_example_2 [a;a;a;a;a;a;a;c;c]. (*returns true *)
  Eval compute in dfa.run automata_example_2 [b;a;d;a;c;c].  (*returns false*)

  (*
  Definition grammar_rules_2 : list (non_terminal1 * rhs.t terminal1 non_terminal1) :=
  [(S, Continue a S);(S, Continue a S1);(S, Continue a S2);(S2, Empty);(S1, Single b)].*)

   Definition grammar_rules2: list (non_terminal1 * rhs.t terminal1 non_terminal1) :=
  [(S1, Continue b S2);(S2, Continue c S3);
     (S3, Single d);
     (S, Continue d S1);(S1, Continue d S1);(S1,Continue c S2);(S2, Continue b S3);
     (S, Continue a S1);(S3, Single a);(S1, Continue a S1)].

  Definition grammar := reg_grammar.build_grammar S grammar_rules2.

  Definition grammar_automaton := powerset_construction.build_dfa grammar.

  Eval compute in dfa.transition_rules grammar_automaton.

  Eval compute in dfa.run grammar_automaton [d;d;b;c;a].

  (* Example : grammmar that have aa or bb as a subword *)
  Definition grammar_aa_bb_rules := [(S, Continue b S); (S, Continue a S1);
  (S1, Continue a S3);(S, Continue b S2); (S2, Continue b S3); (S3, Continue a S3);
  (S3, Continue b S3);(S3, Empty);(S, Continue a S)]. 

  Definition grammar_aa_bb := reg_grammar.build_grammar S grammar_aa_bb_rules.

  Eval compute in reg_grammar.parse grammar_aa_bb [a;a].
  Eval compute in reg_grammar.parse grammar_aa_bb [a;b;b].

  Definition automata_aa_bb := powerset_construction.build_dfa grammar_aa_bb.

  Eval compute in dfa.run2 automata_aa_bb [a;b;a;a;a;b].

 (* ---------------------------------------------------------------------------------- *)
 (* A hand-made NFA for the same automaton.                                            *)
 (*Record t := NFA {
      initial_state : S;
      is_final : list S -> bool;
      next : list S -> A -> list S;
      (* The syntax of the transition rules follows the same idea as for the grammars. *)
      transition_rules : list(list S * rhs.t A (list S))
      (*states : list S;*)
      (*maybe it will be necessary to store the list of states for the minimization algorithm*)
   }.*)

  Definition aa_bb_next (state : list non_terminal1) (t:terminal1) : list non_terminal1 :=
  match state with
  | [] => []
  | [S] => match t with
        | a => [S;S1]
        | b => [S;S2]
        | c => []
        | d => []
        end
  | [S1] => match t with
        | a => [S3]
        | b => []
        | c => []
        | d => []
        end
  | [S2] => match t with
            | a => [S3]
            | b => []
            | c => []
            | d => []
            end
  | [S3] => match t with
            | a => [S3]
            | b => []
            | c => []
            | d => []
            end
  | r::t => []
  end.

  Definition aa_bb_is_final (state: list non_terminal1) : bool :=
  match state with 
  | [S3] => true
  | _ => false
  end.

  Definition aa_bb_list_transitions := [([S], Continue a [S;S1]); ([S], Continue b [S;S2]);
  ([S2], Continue b [S3]); ([S1], Continue a [S3]); ([S3], Continue a [S3]); 
  ([S3], Continue b [S3])].

  Definition aa_bb_nfa := {|
    nfa.initial_state := S;
    nfa.is_final := aa_bb_is_final;
    nfa.next := aa_bb_next;
    nfa.transition_rules := aa_bb_list_transitions |}.
 (*rever o run*)
  Eval compute in nfa.run2 aa_bb_nfa [a].












  Definition test := [(S, Continue a S); (S, Single b)].

  Definition grammar4 := reg_grammar.build_grammar S test.

  Eval compute in reg_grammar.rules grammar4.

  (* TODO adicionar novo elemento no tipo indutivo: quase certo que não da (não dá)   *)
  (* Powerset construction na verdade já gera um DFA a partir da gramática, note que  *)
  (* cada estado é uma lista de possíveis símbolos não terminais (estados do autômato)*)
End examples.
