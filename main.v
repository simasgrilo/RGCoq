Require Import List.
Import ListNotations.
Require Import Classes.EquivDec.
Require Import Coq.Program.Program.
Require Import Bool.
Require Import ListSet.
(*leave the type inference at maximum level in Coq, not being necessary to declare the type*)
(*of parameters of functions, as seen in https://coq.inria.fr/cocorico/CoqNewbieQuestions  *)

Set Implicit Arguments.
(*Coq will try to infer at maximum level the arguments' types *)
Set Maximal Implicit Insertion.

(* First, some library helper functions and notations. *)
(* https://coq.inria.fr/distrib/current/refman/Reference-Manual023.html#hevea_command261/ *)
(*Instance: in this case, the Instance keyword creates a instance of the EqDec class,i.e, *)
(*creates an instance of an equality relation for the type option A (A: Type)             *)
(*Program : gives a way to write programs as if they were written in a regular functional *)
(*programming language, such as Haskell, using the Coq proof apparatus to generate a sound*)
(*program from the specification given.                                                   *)

(*eq: equality relation, it is an inductive proposition that gives the notion of equality *)
(*between 2 elements of the same type. It is in Coq.Init.Logic.                           *)

Obligation Tactic := unfold complement, equiv ; program_simpl.
(*needed tactic, so the obligations generated by Program to deal with the proof of the sound*)
(*ness is solved automatically by the Program keyword.                                     *)

Program Instance option_eqdec A `(EqDec A eq) : EqDec (option A) eq :=
{
  equiv_dec x y :=
    match x, y with
      | Some a, Some b => if a == b then in_left else in_right
      | None, None => in_left
      | Some _, None | None, Some _ => in_right
    end
 }.
(* Equality decidion procedure for pairs *)
Program Instance pair_eqdec A B `(EqDec A eq) `(EqDec B eq) : EqDec (A * B) eq :=
{
  equiv_dec x y :=
    match x,y with
      | pair a b, pair c d => if (a == c) then 
                              if (b == d) then in_left else in_right
                              else in_right
    end
}.
Definition filterMap {A B} (f : A -> option B) : list A -> list B :=
  fix rec (l : list A) : list B :=
    match l with
    | [] => []
    | x :: l => match f x with
               | None => rec l
               | Some y => y :: rec l
               end
    end.

Definition add_list_to_set {A} `{EqDec A eq} : list A -> set A :=
  fix rec l :=
    match l with
    | [] => []
    | a::t => set_add equiv_dec (a) (rec t)
  end.  
Notation "x |> f" := (f x) (left associativity, at level 69, only parsing).

(* A type representing valid right-hand sides of left-regular grammar rules.
   The original email used a much looser representation of rules, which did not
   separate the LHS from the RHS, and which did not enforce regularity. By
   restricting the representation, we make it easier to write a parser. *)
Module rhs.
  (*RHS: Right Hand Side: How right linear regular grammar should behave:its rules should*)
  (*be A -> a, A -> a B or A -> e, where A and B denotes nonterminal symbols and a denotes.*)
  (* a terminal symbol.                                                                   *)

  Inductive t T NT :=
  | Empty : t T NT
  | Single : T -> t T NT
  | Continue : T -> NT -> t T NT.
  (* Coq will infer the type of the arguments of the constructors of the RHS type, as seen in *)
  (*https://coq.inria.fr/distrib/current/refman/Reference-Manual004.html#hevea_command59      *)
  (* so we don't have to worry about expliciting the types every now and then. *)

  Arguments Empty {_} {_}.
  Arguments Single {_} {_} _.
  Arguments Continue {_} {_} _ _.
  (*the function below checks whether a rule is empty or not, given the terminal and nonterminal    *)
  (*and the RHS of a rule, returns true if this RHS is Empty, otherwise, returns false        *)
  Definition isEmpty (T NT : Type) (rhs : rhs.t T NT) : bool :=
    match rhs with
    | Empty => true
    | _ => false
    end.

  Module exports.
    Notation Empty := Empty.
    Notation Single := Single.
    Notation Continue := Continue.
  End exports.
End rhs.
Import rhs.exports.

(* A helper to give us the notion of equality over RHS *)
Program Instance rhs_eqdec A B `(EqDec A eq) `(EqDec B eq) : EqDec (rhs.t A B) eq :=
{
  equiv_dec x y :=
    match x,y with
      | Empty, Empty => in_left
      | Single a, Single b => if a == b then in_left else in_right
      | Continue a nt, Continue b nt' => if a == b then
                                         if nt == nt' then in_left else in_right
                                      else in_right
      | Empty, Single _ => in_right
      | Empty, Continue _ _ => in_right
      | Single _, Empty => in_right
      | Single _, Continue _ _ => in_right
      | Continue _ _, Empty => in_right
      | Continue _ _, Single _ => in_right
    end
}.

Module reg_grammar.
  Section reg_grammar.
    Variable T NT: Type.
    Context  `{EqDec T eq} `{EqDec NT eq}.
    (*When using this, it is possible to use the notion of equality between elements of type*)
    (* T and NT                                                                             *)
    Record g : Type:= {
      start_symbol: NT;
      rules : set (NT * rhs.t T NT);
      terminal_symbols : set T;
      nonterminal_symbols : set NT
    }.
    (* Note that the terminal symbols and nonterminal symbols are implemented as sets *)
    (* It fails if the user provides directly to the record a list with repeated symbols *)    
    Definition build_grammar (nt: NT) rules alphabet nonterminal: g :={|
      start_symbol := nt;
      rules := add_list_to_set (rules);
      terminal_symbols := add_list_to_set (alphabet) ;
      nonterminal_symbols := add_list_to_set (nonterminal) |}.

  (* Next, we're going to write a function [parse] that decides whether a string
     is in the language represented by the grammar. The parser keeps track of
     the set of nonterminal symbols it's currently in, with the additonal
     special symbol None representing "end of string when the last rule applied
     had RHS [Single]". *)

  (* It may help to scroll down to the function [parse] first, and read
     backwards up to here. *)

  (* Given the RHS of a rule and a terminal, decides whether the RHS can be used. *)
  (* In others words, given a RHS of a rule and a terminal symbol, it checks how, if it *)
  (* can be used, the RHS will be used.                                            *)
  Definition step_rhs (t : T) (rhs : rhs.t T NT) : list (option NT) :=
    match rhs with
    | Empty => []
    | Single t' => if t == t' then [None] else []
    | Continue t' nt => if t == t' then [Some nt] else []
    end.

  (* Finds all the productions for a given nonterminal. *)
  (*Note: this list will never be empty, if the nt symbol belongs to the grammar   *)
  Definition getRHS `{EqDec NT eq}
           (nt : NT) : set (NT * rhs.t T NT) ->
                       set (rhs.t T NT) :=
    filterMap (fun rule => let '(nt', rhs) := rule in
                        if nt == nt' then Some rhs else None).


  (* Given a nonterminal [nt], applies all possible rules,applying step_rhs on the             *)
  (* list of nonterminal symbols obtained by applying getRHS nt with the rules of the grammar  *)
  (* Need to reimplement / use other flat_map? *)
  Definition step_nt (rules : set(NT * rhs.t T NT)) (t : T) (nt : NT) : set (option NT) :=
    rules |> getRHS nt  |> flat_map (step_rhs t).


  (* Given a *list* of nonterminals, takes all possible next steps. *)
  (*map: returns 1 value for each application of the function for each element of the list. *)
  (*flat_map: returns 0 or more values for each application of the function in each list element.*)
  (*if applyable *)
  Definition step (rules : set (NT * rhs.t T NT)) (t : T) (acc : list NT) : set (option NT) :=
    acc |> flat_map (step_nt rules t) |> nodup equiv_dec.


  (* The main parser loop. Repeatedly steps the current set of states using
     terminals from the string. *)
  Definition parse' (rules : set (NT * rhs.t T NT))
           : list T -> set (option NT) -> set (option NT) :=
    fix rec l acc :=
      match l with
      | [] => acc
      | t :: l =>
    (*filtermap id : acc gets the elements of t::l. *)
        acc |> filterMap id
            |> step rules t
            |> rec l
      end.
  (* Checks to see if the current state represents an accepting state.  In this
     representataion of state, a state is accepting if it contains [None] or if
     it contains [Some nt] and there is a rule [(nt, Empty)].  *)
  Definition is_final (rules : list (NT * rhs.t T NT)) (l : set (option NT)) : bool :=
  (*existsb: boolean exists, chech whether a condition can
  be met by any of the elements in l*)
  (*This function is in Coq.Lists, where o is an element of the list l.*)
  (* Note that the order of the elements in this list does not affect the result,*)
  (* because for all elements of the list it is checked whether a state is final *)
  (*according to the rules.                                                      *)
    existsb (fun o => match o with
                   | None => true
                   | Some nt => getRHS nt rules |> existsb rhs.isEmpty
                   end)
            l.
  (* Top-level parse function. Calls [parse'] with the initial symbol and checks
     to see whether the resulting state is accepting. *)
  Definition parse (grammar : reg_grammar.g) (l : list T): bool :=
    [Some (start_symbol grammar)] |> parse' (rules grammar) l |> is_final (rules grammar).

  Definition parse_aux (grammar: reg_grammar.g) (l:list T) :=
   [Some (start_symbol grammar)] |> parse' (rules grammar) l.

  End reg_grammar.
End reg_grammar.

(* Nondeterministic finite automata *)
Module nfa.
  Section nfa.
    Variable (S A : Type).
    Context  `{EqDec S eq} `{EqDec A eq}.

    Record t := NFA {
      initial_state : S;
      is_final : S -> bool;
      next : A -> S -> set S;
      states: set S;
      alphabet: set A
   }.
    (* run' is the function that does the verification steps of the automata, applying     *)
    (* the transition functions in the list of terminal symbols, returning a state, which  *)
    (* can be final or not.                                                                *)

    Definition step (nfa:t) (states : set S) (t:A) : list S :=
      states |> flat_map (next nfa t).

    (* Since a NFA can have multiple paths for a single run, we have to check them all. *)
    Definition run' (m: t)
           : list A -> list S -> list S :=
    fix rec l acc :=
      match l with
      | [] => acc
      | t :: l => step m acc t
               |> rec l
      end.
    (* The acceptance criteria is sliglty modified : since we can reach more than one state *)
    (* while going through a word, we have to check whether the nfa can be at (at least) one*)
    (* final state. The verify_final_state function goes though a list of possible states   *)
    (* and checks if one of them is a final state. The run function will go through a word, *)
    (* returning true iff the nfa reached a final state, otherwise it returns false.        *)

    Definition verify_final_state' (m:t) (states: set S) :=
      existsb (fun x => is_final m x) states.

    (* We call the above function to check whether the run in the nfa returns true or false. *)
    Definition run (m : t) (l : list A) : bool :=
     verify_final_state' m ((run' (m) l  ([initial_state m]))).
    Definition run2 (m :t) (l : list A) : set S :=
      nodup equiv_dec (run' (m) l  ([initial_state m])).

    (* The path function returns all the states the automata have been while consuming the *)
    (* word given to be checked whether it is recognizable by the automata or not.         *)
    (*TODO*)
    (* tirar ocorrência de lista vazia (ou não) *)
    Definition get_trace (m:t) : list A -> list S -> list (list S) -> list (list S):=
      fix rec l acc res :=
        match l with
        | [] => res
        | t::l => (res ++ ([step m acc t |> nodup equiv_dec])) |> rec l (step m acc t)
        end.

    Definition path (m:t) (l:list A) : list (set S) :=
      get_trace m l [initial_state m] [[initial_state m]].

  Fixpoint create_continue_rule_from_list (s:S) (ls:set S) (a:A) :=
    match ls with  
    | [] => []
    | x::t => set_add equiv_dec (s,Continue a x) (create_continue_rule_from_list s t a)
    end.

  (* We can build a regular grammar from a NFA: *)
  (* Gets all possible nonempty rules from every transition from the NFA *)
  Definition get_every_state (m:t) (s: S) : set A -> set (S * rhs.t A S) :=
    fix rec l :=
      match l with
      | [] => []
      | a::t => set_union equiv_dec (
                match (nfa.next m a s) with
                | [] => []
                | b::y => (create_continue_rule_from_list (s) (nfa.next m a s) (a))
                end)
    (rec t)
    end.
  (* Gets all rules from all states of the NFA *)
  Fixpoint get_all_rules (m:t) (s: set S) (l: set A): 
  set (S * rhs.t A S):=
  match s with
    | [] => []
    | a::x =>  set_union equiv_dec (get_every_state m a l)
               (get_all_rules m x l)
  end.

  (*Creates empty rule from a set of states, getting all final states of the *)
  (* NFA and then creating rules of the kind A -> e                          *)
  Fixpoint create_empty_rules_from_list (m:t) (ls:set S) :
  set (S * rhs.t A S) :=
    match ls with  
    | [] => []
    | x::t => if (nfa.is_final m x) then
              set_add equiv_dec (x,Empty) (create_empty_rules_from_list m t)
              else (create_empty_rules_from_list m t)
    end.

  (* For every state that is final, we create a rule of the kind (A,Empty) *)
  (* OK *)
  Fixpoint get_empty_rules (m:t) (s: S) (l2: list A): set (S * rhs.t A S) :=
  match l2 with
  | [] => []
  | a::x => set_union equiv_dec (create_empty_rules_from_list m ((nfa.next m a s))) 
            (get_empty_rules m s x)
  end.
  (* Gets all empty rules of the resulting grammar for all nonterminals*)
  Fixpoint add_empty_rules (m:t) (l1: list S) (l2: list A)
  : set (S * rhs.t A S) :=
  match l1 with
  | [] => []
  | a::t => set_union equiv_dec (get_empty_rules m a l2) (add_empty_rules m t l2)
  end.
  (* Function that gets both all possible derivation rules from the NFA *)
  Definition nfa_transitions_to_grammar_rules (m:t) (l1:list S) (l2:list A) := 
   set_union equiv_dec
  (get_all_rules m l1 l2) (add_empty_rules m l1 l2).

  (* To create a regular grammar from a NFA, one may call the above function: *)
  Definition build_grammar_from_nfa (m:t) :=
    reg_grammar.build_grammar (nfa.initial_state m) 
    (nfa_transitions_to_grammar_rules m (nfa.states m) (nfa.alphabet m))
    (nfa.alphabet m) (nfa.states m).

  End nfa.
End nfa.

(* TODO: soundness *)
 (* From a regular grammar we can build a NFA that recgonizes the same language *)
Module grammar_to_nfa.
  Section grammar_to_nfa.

  Variables T NT: Type.
  Context `{EqDec T eq} `{EqDec NT eq}.
  Variable g : reg_grammar.g T NT.
  Definition state : Type := option NT.
  Definition init := Some (reg_grammar.start_symbol g).

  Definition final (s : state) : bool :=
    match s with
      | None => true
      | Some nt => reg_grammar.getRHS nt (reg_grammar.rules g) |> existsb rhs.isEmpty
    end.
  Definition next (t : T) (s:state) : list state :=
      reg_grammar.step (reg_grammar.rules g) t (filterMap id [s]).

  (*TODO: alcançabilidade de grafo *)
  Fixpoint get_all_nt (nt: list (NT)) : list (option NT) :=
  match nt with
  | [] => []
  | a::t => [Some a] ++ get_all_nt t 
  end |> nodup equiv_dec.

  Definition build_nfa_from_grammar := nfa.NFA (init) (final) (next) 
  (get_all_nt (reg_grammar.nonterminal_symbols g)) (reg_grammar.terminal_symbols g).

  Lemma same_initial_state :  Some (reg_grammar.start_symbol g) = 
  nfa.initial_state (build_nfa_from_grammar).
  Proof. reflexivity. Qed.

  Definition grammar_to_nfa_aux : forall l, forall s,
  reg_grammar.is_final (reg_grammar.rules g)
    (reg_grammar.parse' (reg_grammar.rules g) l
      s) =
  nfa.verify_final_state' build_nfa_from_grammar
    (nfa.run' build_nfa_from_grammar l
      s).
  Proof.
  intros l. induction l. 
  destruct s.
  - simpl. reflexivity.
  - simpl. unfold final. reflexivity.
  - simpl. intros s. rewrite <- IHl.
  unfold reg_grammar.step. unfold nfa.step.
  unfold build_nfa_from_grammar.
  unfold next. 
  unfold build_nfa_from_grammar. Admitted.

  (*lemma : dfa.is_final m (dfa.run' (dfa.next m) l (s)) =
  nfa.verify_final_state' (dfa.dfa_to_nfa) (nfa.run' (dfa.dfa_to_nfa) l [s]).*)
  (*is_final m (run' (next m) l (next m s a)) =
nfa.verify_final_state' dfa_to_nfa (nfa.run' dfa_to_nfa l [next m s a])
*)

  Definition grammar_to_nfa_sound : forall l,
  reg_grammar.parse g l = nfa.run (build_nfa_from_grammar) l.
  Proof.
  unfold reg_grammar.parse. unfold nfa.run. rewrite same_initial_state.
  induction l.
  - simpl. reflexivity.
  - apply grammar_to_nfa_aux. Qed.

  End grammar_to_nfa.
End grammar_to_nfa.

Module nfa_epsilon.
  Section nfa_epsilon.

  Variables S A e : Type.

  (* We define an inductive type for the transitions of the NFA with epsilon transitions *)

  End nfa_epsilon.
End nfa_epsilon.

Module dfa.
  Section dfa.
    Variables S A: Type.
    Context  `{EqDec S eq} `{EqDec A eq}.

    Record t := DFA {
      initial_state : S;
      is_final : S -> bool;
      next : S -> A -> S;
      states: set S;
      alphabet: set A
    }.

    (*run' is the function that does the verification steps of the automata, applying     *)
    (*the transition functions in the list of terminal symbols, returning a state, which can*)
    (*be final or not.                                                                    *)
    (*acc is a accumulator, a variable that stores the result of the processing upon each ele-*)
    (* ment of the list of terminal symbols. In this case, it receives the result of applying a*)
    (*transition function for each of the elements of the list (if possible). using the fold_left iterator*)

    Definition run' (step: S -> A -> S) (l : list A) (acc : S) : S :=
      fold_left step l acc.
    Definition run (m : t) (l : list A) : bool :=
      is_final m (run' (next m) l (initial_state m)).
    Definition run2 (m :t) (l : list A) : S :=
      run' (next m) l  (initial_state m).

    Definition get_trace (m:t) : list A ->  S -> list S -> list S:=
      fix rec l s res :=
        match l with
        | [] => res
        | t::l => (res ++ [next m s t] ) |> rec l (next m s t)
        end.
    Definition path (m:t) (l:list A) : list S :=
      get_trace m l (initial_state m) [initial_state m] (*|> nodup equiv_dec*).

  (* Building a grammar from a DFA. *)
  (*dfa to grammar: TODO: proof in the .pdf DONE*)
  (* Gets all derivation rules from a given state *)
  Fixpoint get_transitions_from_a_state (m:t) (s: S) (l2: set A): 
  set (S * rhs.t A S):=
  match l2 with
    | [] => []
    | a::x =>  set_add equiv_dec ((s, Continue a (dfa.next m s a)))
               (get_transitions_from_a_state m s x)
  end.
  (* Gets all nonempty derivation rules from all states of the automaton *)
  Fixpoint add_rules (m:t) (l1: set S) (l2: set A)
  : set (S * rhs.t A S) :=
  match l1 with
  | [] => []
  | a::t => set_union equiv_dec
            (get_transitions_from_a_state m a l2)(add_rules m t l2)
  end.

  (* Gets all empty rules of the resulting grammar for a given nonterminal *)
  Fixpoint get_empty_rules (m:t) (s: S) (l2: list A): set (S * rhs.t A S) :=
  match l2 with
  | [] => []
  | a::x => if (is_final m (dfa.next m s a)) then
            set_add equiv_dec ((dfa.next m s a, Empty)) (get_empty_rules m s x)
            else get_empty_rules m s x
  end.

  (* Gets all empty rules of the resulting grammar for all nonterminals*)
  Fixpoint add_empty_rules (m:t) (l1: list S) (l2: list A)
  : set (S * rhs.t A S) :=
  match l1 with
  | [] => []
  | a::t => set_union equiv_dec (get_empty_rules m a l2) (add_empty_rules m t l2)
  end.

  Definition dfa_transitions_to_grammar_rules (m:t) (l1:list S) (l2:list A) := 
   set_union equiv_dec
  (add_rules m l1 l2) (add_empty_rules m l1 l2) .

  Definition recgonizes (dfa: dfa.t) (l: list A) :=
    dfa.run dfa l = true.

  Definition dfa_to_regular_grammar (m:t): reg_grammar.g A S :=
    reg_grammar.build_grammar (initial_state m) 
    (dfa_transitions_to_grammar_rules m (dfa.states m) (dfa.alphabet m))
    (dfa.alphabet m) (dfa.states m).


  (* We can build an NFA from a DFA. *)
  Variable m : t.
  (* The first step is to rewrite the next function of the DFA as the same way it behaves for the NFA*)
  Definition nfa_step(t:A) (s:S) :=
    [dfa.next m s t].

  Definition dfa_to_nfa := nfa.NFA (dfa.initial_state m) (dfa.is_final m)
  (nfa_step) (dfa.states m) (dfa.alphabet m).

  Lemma dfa_to_nfa_sound_aux : forall l, forall s,
  dfa.is_final m (dfa.run' (dfa.next m) l (s)) =
  nfa.verify_final_state' (dfa.dfa_to_nfa) (nfa.run' (dfa.dfa_to_nfa) l [s]).
  Proof. 
  intros.
  generalize dependent s.
  induction l.
  - simpl. intros s.  destruct dfa.is_final;auto.
  - intros. simpl. rewrite IHl. reflexivity. 
  Qed.

  Lemma dfa_to_nfa_sound : forall l,
    dfa.run m l = nfa.run (dfa.dfa_to_nfa) l.
   Proof. 
   unfold nfa.run. unfold dfa.run.
   induction l.
   - simpl. destruct dfa.is_final. reflexivity. reflexivity. 
   - rewrite dfa_to_nfa_sound_aux. reflexivity. 
   Qed.

  (* We can also build a regular grammar from a DFA: *)
   (*proof : TODO*)
  (* not exactly what we want *)
  Lemma dfa_to_regular_grammar_aux : forall l, forall s,
    is_final m (run' (next m) l s) =
    reg_grammar.is_final (reg_grammar.rules (dfa_to_regular_grammar m))
    (reg_grammar.parse' (reg_grammar.rules (dfa_to_regular_grammar m)) l
    [Some s]).
  Proof.
  unfold reg_grammar.is_final.
  induction l. Admitted.

  Lemma dfa_to_regular_grammar_sound : forall l, 
    reg_grammar.parse (dfa_to_regular_grammar m) l = dfa.run m l.
  Proof. 
  unfold run. unfold reg_grammar.parse.
  induction l.
  - simpl. unfold dfa_transitions_to_grammar_rules.
    unfold add_empty_rules. unfold get_empty_rules. simpl.
  Admitted.

  (* Verifying if the DFA is a minimal DFA.                                   *)
  (* idea: a DFA is minimal iff there is no equivalent transition             *)
  (* The first step is to check whether a pair of states is equivalent:       *)
  Definition check_pair_states (m:t) (s1: S) (s2: S) : list A -> bool := 
    fix rec l :=
      match l with
      | [] => true
      | a::t => if (((dfa.next m s1 a) == (dfa.next m s2 a))) 
                then rec t
                else false
    end.

  Fixpoint check_a_pair_states (m:t) (s1: S) (s2: list S) (l:list A) : bool :=
    match s2 with
    | [] => false
    | b::y => if s1 <> b then
                   if (check_pair_states m s1 b l == false)
                   then check_a_pair_states m s1 y l
                   else true
              else check_a_pair_states m s1 y l
    end.

  (* Then we can check for all states of the automaton if there is no equivale-*)
  (* nt state in the automaton.                                                *)
  Definition has_equivalent_states (m:t): list S -> list S -> list A -> bool :=
    fix rec s1 s2 l :=
      match s1 with
      | [] => false
      | a::t => check_a_pair_states m (a) s2 l || rec t s2 l
    end.

  Definition is_minimal (m:t) :=
    negb (has_equivalent_states  m (dfa.states m) (dfa.states m) (dfa.alphabet m)).

  (* We can also return the pair of states that are equivalent *)
  Fixpoint get_equivalent_states (m:t) (s1: S) (s2: list S) (l:list A) : list (S * S) :=
    match s2 with
    | [] => []
    | b::y => if s1 <> b then
                   if (check_pair_states m s1 b l == true)
                   then [(s1,b)] ++ get_equivalent_states m s1 y l
                   else get_equivalent_states m s1 y l
              else get_equivalent_states m s1 y l
    end.

  Definition get_all_equivalent_states (m:t): list S -> list S -> list A -> list (S * S) :=
    fix rec s1 s2 l :=
      match s1,s2 with
      | [],[] => []
      | a::t,x::y => get_equivalent_states m (a) s2 l ++ rec t y l
      | _,_ => []
    end.

  (* Top level function that returns pairs of equivalent states *)
  Definition check_equivalent_states (m:t) :=
    get_all_equivalent_states m (dfa.states m) (dfa.states m) (dfa.alphabet m).

  End dfa.
End dfa.

Module nfa_to_dfa.
  Section nfa_to_dfa.

  Variables S A : Type.
  Context `{EqDec A eq} `{EqDec S eq}.
  Variable m: nfa.t S A.
 
  (* We implement the conversion of NFA to DFA using the powerset construction          *)
  (* algorith on the fly. Then, a state in the DFA is built according to the algorithm. *)
  Definition state := set S.
  (*The initial state of the DFA is the same of the NFA. *)
  Definition init : state := [nfa.initial_state m].
  (*The final states of the DFA will be the states that were built from at least*)
  (* one final state of the NFA                                                 *)
  Definition final (s : state) : bool :=
    nfa.verify_final_state' (m) s.
  Definition dfa_alphabet := nfa.alphabet m.
  (* busca em largura! *)
  (*set_add \passar geral pra set (tenso no caso das regras) OK*)
  (* Get the reachable states from one state *)
  (* Fixpoint list_states (s:S) (l: list A) :  set state :=
    match l with
    | [] => []
    | a::t => if (nfa.next m a s <> []) then
              set_add equiv_dec (nfa.next m a s) (list_states s t)
              else list_states s t
  end.

  Fixpoint list_states2 (s: state) (l: list A) : set (set state) :=
    match s with
    | [] => []
    | a::t => set_add equiv_dec (list_states a l) (list_states2 t l)
    end.
  (* Get all reachable states of the NFA built from the DFA *)
  Definition get_all_states :  set A -> set (set state) :=
    fix rec l acc :=
    match acc with
    | [] => []
    | b::y => set_add equiv_dec (list_states b l) (acc)
                    |> rec l
    end.
  end.  *)

  (* Depth-first search for listing all reachable states. How?*)
  (* idea: for a single symbol of the alphabet, we check if from a given state it *)
  (* goes to another state different from the one we are checking. *)
  (*Definition list_state (m:nfa.t A S) (s: state) (t: A) : set state -> set state :=
  fix rec acc:=
    match s with
    | [] => acc
    | a::x => if ((nfa.next m t a) <> s) then
              set_add (nfa.step m a s) (acc) |> rec (m) (acc) (t)
              else (rec m (nfa.step m a s) t acc)
    end.
    *)

  Definition dfa_states := [nfa.states m]. (*wrong, have to list 'em all. *)
  Definition dfa_next (s:state) (a:A) : state := nfa.step m s a.
  Check dfa_next.

  Definition build_dfa_from_nfa := dfa.DFA (init) (final) (dfa_next) (dfa_states)
    (dfa_alphabet).

  End nfa_to_dfa.
End nfa_to_dfa.

(* We can also explicitly construct a DFA corresponding to the grammar. In fact, all
   the hard work was already done in our grammar parser. *)
Module powerset_construction.
  Section powerset_construction.

    Variable T NT : Type.
    Context `{EqDec T eq} `{EqDec NT eq}.
    (*a valid regular grammar shall follow the rules of g, where T and NT are, respectively, *)
    (* the terminal and nonterminal symbols.                                                 *)
    Variable g : reg_grammar.g T NT.
    Definition state : Type := list (option NT).
    (* The automata's inital state is the same as the start symbol of the grammar.           *)

    Definition init : state := [Some (reg_grammar.start_symbol g)].
    (*The same goes to a final state in the automaton. *)
    Definition is_final (s : state) : bool :=
      reg_grammar.is_final (reg_grammar.rules g) s.
    Definition next (s : state) (t : T) : state :=
      reg_grammar.step (reg_grammar.rules g) t (filterMap id s).

    Definition alphabet := (reg_grammar.terminal_symbols g).

    (* bugged *)
    Definition get_states_from_state (s:state) : set T -> set state :=
    fix rec l :=
    match l with
    | [] => []
    | a::t => if (powerset_construction.next s a <> [])
              then [powerset_construction.next s a] ++ rec t
              else rec t
    end.

  (*bugged *)
  Fixpoint nt_to_state (l : list NT) : list state :=
  match l with
    | [] => []
    | a::t => [[Some a]] ++ nt_to_state t
  end.

  Definition build_dfa := dfa.DFA (init) (is_final) (next) (nt_to_state (reg_grammar.nonterminal_symbols g))
    (reg_grammar.terminal_symbols g).

  End powerset_construction.
End powerset_construction.

Module regular_expression.
  Section regular_expression.

  (* Adapted from the book "Software Foundations" *)
  (* Incomplete *)

  Inductive reg_exp (T : Type) : Type :=
  | EmptySet : reg_exp T
  | EmptyStr : reg_exp T
  | Char : T -> reg_exp T
  | App : reg_exp T -> reg_exp T -> reg_exp T
  | Union : reg_exp T -> reg_exp T -> reg_exp T
  | Star : reg_exp T -> reg_exp T.

  Arguments EmptySet {T}.
  Arguments EmptyStr {T}.
  Arguments Char {T} _.
  Arguments App {T} _ _.
  Arguments Union {T} _ _.
  Arguments Star {T} _.

  Inductive exp_match {T} : list T -> reg_exp T -> Prop :=
  | MEmpty : exp_match [] EmptyStr
  | MChar : forall x, exp_match [x] (Char x)
  | MApp : forall s1 re1 s2 re2,
             exp_match s1 re1 ->
             exp_match s2 re2 ->
             exp_match (s1 ++ s2) (App re1 re2)
  | MUnionL : forall s1 re1 re2,
                exp_match s1 re1 ->
                exp_match s1 (Union re1 re2)
  | MUnionR : forall re1 s2 re2,
                exp_match s2 re2 ->
                exp_match s2 (Union re1 re2)
  | MStar0 : forall re, exp_match [] (Star re)
  | MStarApp : forall s1 s2 re,
                 exp_match s1 re ->
                 exp_match s2 (Star re) ->
                 exp_match (s1 ++ s2) (Star re).

  Notation "s =~ re" := (exp_match s re) (at level 80).

  Fixpoint re_chars {T} (re : reg_exp T) : list T :=
    match re with
    | EmptySet => []
    | EmptyStr => []
    | Char x => [x]
    | App re1 re2 => re_chars re1 ++ re_chars re2
    | Union re1 re2 => re_chars re1 ++ re_chars re2
    | Star re => re_chars re
    end.

  Inductive test := a | b.

  End regular_expression.
End regular_expression.

Module examples.
  Module non_terminal.
    Inductive t:Type :=
      A | B.

    Program Instance eqdec : EqDec t eq :=
      { equiv_dec x y :=
          match x, y with
          | A, A => in_left
          | B, B => in_left
          | A, B | B, A => in_right
          end
      }.
  End non_terminal.

  Module terminal.
    Inductive t : Type :=
      a | b.

    Program Instance eqdec : EqDec t eq :=
      { equiv_dec x y :=
          match x, y with
          | a, a => in_left
          | b, b => in_left
          | a, b | b, a => in_right
          end
      }.
  End terminal.

  Definition a_b_rules: set (non_terminal.t * rhs.t terminal.t non_terminal.t):=
    [(non_terminal.A, Continue terminal.a non_terminal.A);
     (non_terminal.A, Continue terminal.b non_terminal.B);
     (non_terminal.A, Empty);
     (non_terminal.B, Continue terminal.b non_terminal.B);
     (non_terminal.B, Empty)].

  Definition a_b_grammar : reg_grammar.g terminal.t non_terminal.t :=
    {| reg_grammar.start_symbol := non_terminal.A;
       reg_grammar.rules := a_b_rules;
       reg_grammar.terminal_symbols := [terminal.a;terminal.b];
       reg_grammar.nonterminal_symbols := [non_terminal.A; non_terminal.B] |}.

  (* A few examples. *)
  Eval compute in reg_grammar.parse a_b_grammar [].
  Eval compute in reg_grammar.parse a_b_grammar [terminal.a].
  Eval compute in reg_grammar.parse a_b_grammar [terminal.a; terminal.a].
  Eval compute in reg_grammar.parse a_b_grammar [terminal.b; terminal.b].
  Eval compute in reg_grammar.parse a_b_grammar [terminal.a; terminal.b].
  Eval compute in reg_grammar.parse a_b_grammar [terminal.b; terminal.a].

  (*An NFA built from the grammar given above *)

  Definition nfa_from_a_b_grammar := grammar_to_nfa.build_nfa_from_grammar a_b_grammar.
  Eval compute in nfa.path nfa_from_a_b_grammar [].
  Eval compute in nfa.run nfa_from_a_b_grammar [terminal.a; terminal.a;terminal.b; terminal.a].
  Eval compute in nfa.run nfa_from_a_b_grammar [terminal.a; terminal.a].
  Eval compute in nfa.run nfa_from_a_b_grammar [terminal.a; terminal.b].
  Eval compute in nfa.run nfa_from_a_b_grammar [terminal.b; terminal.a].
  Eval compute in nfa.states nfa_from_a_b_grammar.

  (* A hand rolled DFA for the same language. *)
  Definition a_b_next (s : option non_terminal.t) (t : terminal.t) : option non_terminal.t :=
    match s with
    | None => None
    | Some non_terminal.A =>
      match t with
      | terminal.a => Some non_terminal.A
      | terminal.b => Some non_terminal.B
      end
    | Some non_terminal.B =>
      match t with
      | terminal.a => None
      | terminal.b => Some non_terminal.B
      end
    end.

  Definition a_b_is_final (s : option non_terminal.t) : bool :=
    match s with
    | None => false
    | Some _ => true
    end.

  (*Definition a_b_transition_rules : list (option non_terminal.t * fa_rules.fa_transitions terminal.t (option non_terminal.t)) :=
  [(Some non_terminal.A, Goes terminal.a (Some non_terminal.A));
     (Some non_terminal.A, Goes terminal.b (Some non_terminal.B));
     (Some non_terminal.B, Goes terminal.b (Some non_terminal.B))]. *)

  Definition a_b_states := [Some non_terminal.A; Some non_terminal.B].

  Definition a_b_dfa : dfa.t _ _  :=
    {| dfa.initial_state := Some non_terminal.A;
       dfa.is_final := a_b_is_final;
       dfa.next := a_b_next;
       dfa.states := a_b_states;
       dfa.alphabet := [terminal.a;terminal.b] |}.

  (* Examples running the DFA. *)
  Eval compute in dfa.run a_b_dfa [].
  Eval compute in dfa.run a_b_dfa [terminal.a].
  Eval compute in dfa.run a_b_dfa [terminal.b].
  Eval compute in dfa.run a_b_dfa [terminal.a; terminal.a].
  Eval compute in dfa.run a_b_dfa [terminal.b; terminal.b].
  Eval compute in dfa.run a_b_dfa [terminal.a; terminal.b].
  Eval compute in dfa.run a_b_dfa [terminal.b; terminal.b;terminal.a].
  Eval compute in dfa.path a_b_dfa [terminal.b;terminal.b;terminal.a;terminal.a].


  (* Automatically construct a DFA using the powerset construction. *)
  Check a_b_grammar.
  Definition a_b_dfa' := powerset_construction.build_dfa a_b_grammar.
  Check a_b_dfa'.
  Eval compute in reg_grammar.nonterminal_symbols a_b_grammar.
  Eval compute in dfa.dfa_transitions_to_grammar_rules a_b_dfa'
  (dfa.states a_b_dfa') (dfa.alphabet a_b_dfa').
  Definition back_to_grammar := dfa.dfa_to_regular_grammar a_b_dfa'.
  Eval compute in (reg_grammar.rules back_to_grammar).

  (* Examples running the second DFA. *)
  Eval compute in dfa.run a_b_dfa' [].
  Eval compute in dfa.run a_b_dfa' [terminal.a].
  Eval compute in dfa.run a_b_dfa' [terminal.a; terminal.a].
  Eval compute in dfa.run a_b_dfa' [terminal.b; terminal.b].
  Eval compute in dfa.run a_b_dfa' [terminal.a; terminal.b].
  Eval compute in dfa.run a_b_dfa' [terminal.a; terminal.b;terminal.b].
  Eval compute in dfa.run a_b_dfa' [terminal.b; terminal.a].

  (*We can check if the automaton is a minimal automaton: *)
  Eval compute in dfa.is_minimal a_b_dfa'.
  Eval compute in dfa.states a_b_dfa'.

  (*We can build a NFA from the DFA given above :*)

  Definition nfa_from_dfa_a_b := dfa.dfa_to_nfa a_b_dfa.
  Check dfa.dfa_to_nfa.
  Check nfa_from_dfa_a_b.
  Check a_b_dfa'.

  Eval compute in nfa.run nfa_from_dfa_a_b [].
  Eval compute in nfa.run nfa_from_dfa_a_b [terminal.a;terminal.a;terminal.b;terminal.a].
  Eval compute in nfa.run nfa_from_dfa_a_b [terminal.a; terminal.a].
  Eval compute in nfa.run nfa_from_dfa_a_b [terminal.b; terminal.b].
  Eval compute in nfa.run nfa_from_dfa_a_b [terminal.a; terminal.b].
  Eval compute in nfa.run nfa_from_dfa_a_b [terminal.a; terminal.b;terminal.b].
  Eval compute in nfa.run nfa_from_dfa_a_b [terminal.b; terminal.a].

  (*and we have that they run recgonize the same language *)
  Lemma nfa_from_dfa_a_b_good : forall l, dfa.run a_b_dfa l = nfa.run nfa_from_dfa_a_b l.
  Proof.
  apply dfa.dfa_to_nfa_sound.
  Qed.

  (* We can also build a grammar from the automaton given above: *)
  Definition a_b_grammar2 := dfa.dfa_to_regular_grammar a_b_dfa.
  Eval compute in dfa.states a_b_dfa'.
  Eval compute in dfa.alphabet a_b_dfa.
  Eval compute in reg_grammar.rules a_b_grammar2.

  Eval compute in reg_grammar.parse a_b_grammar2 [].
  Eval compute in reg_grammar.parse a_b_grammar2 [terminal.a;terminal.b;terminal.a].
  Eval compute in reg_grammar.parse a_b_grammar2 [terminal.b;terminal.b].
  Eval compute in reg_grammar.parse a_b_grammar2 [terminal.a;terminal.b;terminal.b].

  Inductive non_terminal1 := S| S1 | S2 | S3 |S4.
  Inductive terminal1 := a | b |c | d.

  Definition grammar_rules: list (non_terminal1 * rhs.t terminal1 non_terminal1) :=
  [(S, Continue a S1); (S, Empty);
     (S1, Continue b S2);
     (S2, Continue c S3);
     (S3, Single d);(S3, Continue a S)].

  Program Instance eqdec : EqDec non_terminal1 eq :=
      { equiv_dec x y :=
          match x, y with
          | S,S => in_left
          | S1, S1 => in_left
          | S2, S2 => in_left
          | S3, S3 => in_left
          | S4, S4 => in_left
          | S, S1|S1,S| S, S2 | S2, S | S, S3 | S3, S | S1, S2 | S2, S1 | S1, S3 | S3, S1 
          | S2, S3 | S3, S2| S4, S | S4, S1 | S4, S2 | S4, S3| S,S4 |S1, S4| S2, S4| S3,S4 => in_right
          end
      }.
    Program Instance eqdec2 : EqDec terminal1 eq :=
      { equiv_dec x y :=
          match x, y with
          | a,a => in_left
          | b, b => in_left
          | c, c => in_left
          | d, d => in_left
          | a, b| b,a| a, c | c, a | a, d | d, a | b, c | c, b | b, d | d, b 
          | c, d | d, c => in_right
          end
      }.

  Definition grammar_example := reg_grammar.build_grammar S grammar_rules
     [a;b;c;d;a;b;c;c;c;d] [S;S1;S2;S3;S4].
  Eval compute in reg_grammar.terminal_symbols grammar_example.
  Definition automata_example := powerset_construction.build_dfa grammar_example.

  Eval compute in dfa.run automata_example [a;b;c].
  Eval compute in dfa.run automata_example [a;b;b;c;d].
  Eval compute in dfa.run automata_example [].

  Definition rules_example_2 : list(non_terminal1 * rhs.t terminal1 non_terminal1) :=
  [(S,Continue a S1);(S, Single a);(S,Continue b S2);(S1, Continue a S1);(S1,Continue c S3);(S2,Continue b S2);
  (S2, Continue d S4);(S3, Single c);(S3,Continue c S);
  (S4, Single d);(S4,Continue d S)].

  (* Another example of a DFA built from a grammar: *)
  Definition grammar_example_2 := reg_grammar.build_grammar S rules_example_2
    [b;c;a;d] [S;S1;S2;S3;S4].
  Definition automata_example_2 := powerset_construction.build_dfa grammar_example_2.

  Eval compute in dfa.run automata_example_2 [b;d;d]. (*returns true*)
  Eval compute in dfa.run automata_example_2 [b;d;d;c]. (*returns false*)
  Eval compute in dfa.run automata_example_2 [a;c;c]. (*returns true*)
  Eval compute in dfa.run automata_example_2 [a;c;c;b;d;d]. (*returns true*)
  Eval compute in dfa.run automata_example_2 [b;d;d;a;b;c;c].    (*returns false*)
  Eval compute in dfa.run automata_example_2 [b;b;b;b;b;b;b;d;d;a;c;c]. (*returns true*)
  Eval compute in dfa.run automata_example_2 [b;d;d;a;c;c;b;d;d;b;d;d]. (*returns true*)
  Eval compute in dfa.run automata_example_2 [a;a;a;a;a;a;a;c;c]. (*returns true *)
  Eval compute in dfa.run automata_example_2 [b;a;d;a;c;c].  (*returns false*)

  (* The above automaton is minimal: *)
  Eval compute in dfa.is_minimal automata_example_2.
  (* Then, the list of pairs of equivalent states is an empty list. *)
  Eval compute in dfa.check_equivalent_states automata_example_2.

  Definition grammar_rules2: list (non_terminal1 * rhs.t terminal1 non_terminal1) :=
    [(S1, Continue b S2);(S2, Continue c S3);(S3, Single d);
     (S, Continue d S1);(S1, Continue d S1);(S1,Continue c S2);(S2, Continue b S3);
     (S, Continue a S1);(S3, Single a);(S1, Continue a S1)].

  Definition grammar := reg_grammar.build_grammar S grammar_rules2
    [a;b;c;d] [S;S1;S2;S3].

  Definition grammar_automaton := powerset_construction.build_dfa grammar.

  Eval compute in dfa.run grammar_automaton [d;d;b;c;a].
  Eval compute in dfa.path grammar_automaton [d;d;b;c;a].
  Eval compute in dfa.run grammar_automaton [b].
  Eval compute in dfa.path grammar_automaton [b].

  (* Example : grammmar that have aa or bb as a subword *)
  Definition grammar_aa_bb_rules := [(S, Continue b S); (S, Continue a S1);
  (S1, Continue a S3);(S, Continue b S2); (S2, Continue b S3); (S3, Continue a S3);
  (S3, Continue b S3);(S3, Empty);(S, Continue a S)].

  Definition grammar_aa_bb := reg_grammar.build_grammar S grammar_aa_bb_rules
    [a;b] [S;S1;S2;S3].

  Eval compute in reg_grammar.parse grammar_aa_bb [a;a].
  Eval compute in reg_grammar.parse grammar_aa_bb [a;b;b].
  Eval compute in reg_grammar.parse grammar_aa_bb [a;b].

  Definition automata_aa_bb := powerset_construction.build_dfa grammar_aa_bb.

  Eval compute in dfa.run automata_aa_bb  [a;b;a;a;a;b].
  Eval compute in dfa.run2 automata_aa_bb [a;b;a;a;a;b].
  Eval compute in dfa.path automata_aa_bb [a;b;a;a;a;b].

 (* ---------------------------------------------------------------------------------- *)
 (* A hand-made NFA for the same language.                                            *)

  Definition aa_bb_next (t:terminal1) (state : non_terminal1) : list non_terminal1 :=
  match state with
  | S => match t with
        | a => [S;S1]
        | b => [S;S2]
        | c => []
        | d => []
        end
  | S1 => match t with
        | a => [S3]
        | b => []
        | c => []
        | d => []
        end
  | S2 => match t with
            | a => []
            | b => [S3]
            | c => []
            | d => []
            end
  | S3 => match t with
            | a => [S3]
            | b => [S3]
            | c => []
            | d => []
            end
  | S4 => []
  end.

  Definition aa_bb_is_final (state: non_terminal1) : bool :=
  match state with 
  | S3 => true
  | _ => false
  end.

  Definition aa_bb_nfa := {|
    nfa.initial_state := S;
    nfa.is_final := aa_bb_is_final;
    nfa.next := aa_bb_next;
    nfa.states := [S;S1;S2;S3];
    nfa.alphabet := [a;b] |}.

  Eval compute in nfa.path aa_bb_nfa [a;a;b;a;a;a;a;a].
  Eval compute in nfa.run aa_bb_nfa [a;a;b;a].
  Eval compute in nfa.run aa_bb_nfa [b;a;b;b].
  Eval compute in nfa.path aa_bb_nfa [b;a;b;b;b;b;a].
  Eval compute in nfa.run2 aa_bb_nfa [b;a;b;b;b;b;b;b;b].
  Eval compute in nfa.path aa_bb_nfa [b;a;b;b;b;b;b;b;b].

  (*And we can build a DFA from the NFA defined above *)

  Definition aa_bb_dfa := nfa_to_dfa.build_dfa_from_nfa aa_bb_nfa.
  Eval compute in dfa.path aa_bb_dfa [a;a].
  Eval compute in dfa.run aa_bb_dfa [a;a;a;a;b;b].

  (*NEW we can also build a grammar from the NFA defined above *)
  Definition aa_bb_grammar := nfa.build_grammar_from_nfa aa_bb_nfa.
  Eval compute in reg_grammar.rules aa_bb_grammar.
  Eval compute in reg_grammar.parse aa_bb_grammar [a;a;b;a;a;a;a;a].

  Definition test := [(S, Continue a S); (S, Single b)].

  Definition grammar4 := reg_grammar.build_grammar S test [a;b] [S].

  Eval compute in reg_grammar.rules grammar4.

  Inductive naoterminal := A | B | C | D | E | F | G.
  Inductive terminal := x|y.

  Program Instance exemplo : EqDec naoterminal eq :=
      { equiv_dec x y :=
          match x, y with
          | A,A => in_left
          | B,B => in_left
          | C,C=> in_left
          | D,D => in_left
          | E,E => in_left
          | F,F => in_left
          | G, G => in_left
          | A,B | B,A | A,C| C, A| A,D| D,A | A,E| E,A |A,F | F,A| B,C| C,B |B ,D
          | D,B | B,E |E,B |B,F |F,B | C,D| D,C | C,E | E,C | C,F|F,C| D,E |E,D
          | E,F |F, E | D,F | F, D | A, G | G, A | B, G| G,B |G, C | C, G
          | G,D| D,G |E, G |G ,E | G, F| F, G => in_right
          end
      }.

  Program Instance exemplo2 : EqDec terminal eq :=
    {equiv_dec x y :=
      match x, y with
      | x,x => in_left
      | y,y => in_left
      | x,y |y,x => in_right
      end
    }.

  Definition regras := [(A, Continue a B);(A, Continue b C); (B, Continue a D);
  (B, Continue a E); (C, Continue a E); (C, Continue a D); (D, Continue a F);
  (E, Continue b F); (F, Empty) ;(G, Continue c F)].

  Definition gramática := reg_grammar.build_grammar A regras [a;b] [A;B;C;D;E;F;G].

  Definition automato_gramatica := powerset_construction.build_dfa gramática.

  Eval compute in dfa.run automato_gramatica [b;a;a;c].
  Eval compute in dfa.path automato_gramatica [b;a;a;c].
  Eval compute in dfa.run2 automato_gramatica [c].


  (* an example of an automaton that is not minimal *)
  Module e.
    Inductive states := q0 |q1 | q2 |q3 | q4.
    Inductive alphabet := a | b.

    Program Instance eqstates : EqDec states eq := 
	    {equiv_dec x y := 
		    match x, y with 
		    | q0,q0 => in_left 
		    | q1,q1 => in_left 
		    | q2,q2 => in_left 
		    | q3,q3 => in_left 
		    | q4,q4 => in_left 
		    | q0,q1 => in_right 
		    | q0,q2 => in_right 
		    | q0,q3 => in_right 
		    | q0,q4 => in_right 
		    | q1,q0 => in_right 
		    | q1,q2 => in_right 
		    | q1,q3 => in_right 
		    | q1,q4 => in_right 
		    | q2,q0 => in_right 
		    | q2,q1 => in_right 
		    | q2,q3 => in_right 
		    | q2,q4 => in_right 
		    | q3,q0 => in_right 
		    | q3,q1 => in_right 
		    | q3,q2 => in_right 
		    | q3,q4 => in_right 
		    | q4,q0 => in_right 
		    | q4,q1 => in_right 
		    | q4,q2 => in_right 
		    | q4,q3 => in_right 
		    end 
	    }.

    Program Instance eqalphabet : EqDec alphabet eq :=
      {equiv_dec x y := 
		    match x, y with 
        | a,a | b,b => in_left
        | a,b | b,a => in_right
        end
      }.
  End e.

  Definition example_next (s: option e.states) (a: e.alphabet) :=
    match s with
      | None => None
      |Some e.q0 => match a with
               |e.a => Some e.q1
               |e.b => None
               end
      |Some e.q1 => match a with
             |e.a => Some e.q3
             |e.b => Some e.q2
              end
      |Some e.q2 => match a with
             |e.a => Some e.q4
             |e.b => Some e.q2
             end
      |Some e.q3 => match a with
             |e.a => Some e.q3
             |e.b => Some e.q2
              end
      |Some e.q4 => match a with
             |e.a => Some e.q3
             |e.b => Some e.q2
              end
    end.

  Definition example_is_final (s: option e.states) :=
    match s with
      | Some e.q4 | Some e.q3 => true
      | None | Some _=> false
    end.

  Definition nonminimal_automaton :=
    {| dfa.initial_state := Some e.q0;
       dfa.is_final := example_is_final;
       dfa.next := example_next;
       dfa.states := [Some e.q0;Some e.q1;Some e.q2;Some e.q3;Some e.q4];
       dfa.alphabet := [e.b;e.a] |}.

  Eval compute in dfa.run nonminimal_automaton [e.a;e.b;e.a].
  Eval compute in dfa.is_minimal nonminimal_automaton.
  Eval compute in dfa.check_equivalent_states nonminimal_automaton.

End examples.